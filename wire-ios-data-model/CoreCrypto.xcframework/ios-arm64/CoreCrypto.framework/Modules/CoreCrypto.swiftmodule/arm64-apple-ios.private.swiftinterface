// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios15.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CoreCrypto
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import CoreCrypto
import Foundation
import Swift
import _Concurrency
import _StringProcessing
public protocol CoreCryptoProtocol {
  func mlsInit(clientId: CoreCrypto.ClientId, ciphersuites: [CoreCrypto.CiphersuiteName]) throws
  func mlsGenerateKeypairs(ciphersuites: [CoreCrypto.CiphersuiteName]) throws -> [[Swift.UInt8]]
  func mlsInitWithClientId(clientId: CoreCrypto.ClientId, signaturePublicKeys: [[Swift.UInt8]], ciphersuites: [CoreCrypto.CiphersuiteName]) throws
  func restoreFromDisk() throws
  func setCallbacks(callbacks: CoreCrypto.CoreCryptoCallbacks) throws
  func clientPublicKey(ciphersuite: CoreCrypto.CiphersuiteName) throws -> [Swift.UInt8]
  func clientKeypackages(ciphersuite: CoreCrypto.CiphersuiteName, amountRequested: Swift.UInt32) throws -> [[Swift.UInt8]]
  func clientValidKeypackagesCount(ciphersuite: CoreCrypto.CiphersuiteName) throws -> Swift.UInt64
  func createConversation(conversationId: CoreCrypto.ConversationId, config: CoreCrypto.ConversationConfiguration) throws
  func conversationEpoch(conversationId: CoreCrypto.ConversationId) throws -> Swift.UInt64
  func conversationExists(conversationId: CoreCrypto.ConversationId) -> Swift.Bool
  func processWelcomeMessage(welcomeMessage: [Swift.UInt8], customConfiguration: CoreCrypto.CustomConfiguration) throws -> CoreCrypto.ConversationId
  func addClientsToConversation(conversationId: CoreCrypto.ConversationId, clients: [CoreCrypto.Invitee]) throws -> CoreCrypto.MemberAddedMessages
  func removeClientsFromConversation(conversationId: CoreCrypto.ConversationId, clients: [CoreCrypto.ClientId]) throws -> CoreCrypto.CommitBundle
  func markConversationAsChildOf(childId: CoreCrypto.ConversationId, parentId: CoreCrypto.ConversationId) throws
  func updateKeyingMaterial(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.CommitBundle
  func commitPendingProposals(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.CommitBundle?
  func wipeConversation(conversationId: CoreCrypto.ConversationId) throws
  func decryptMessage(conversationId: CoreCrypto.ConversationId, payload: [Swift.UInt8]) throws -> CoreCrypto.DecryptedMessage
  func encryptMessage(conversationId: CoreCrypto.ConversationId, message: [Swift.UInt8]) throws -> [Swift.UInt8]
  func newAddProposal(conversationId: CoreCrypto.ConversationId, keyPackage: [Swift.UInt8]) throws -> CoreCrypto.ProposalBundle
  func newUpdateProposal(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.ProposalBundle
  func newRemoveProposal(conversationId: CoreCrypto.ConversationId, clientId: CoreCrypto.ClientId) throws -> CoreCrypto.ProposalBundle
  func newExternalAddProposal(conversationId: CoreCrypto.ConversationId, epoch: Swift.UInt64, ciphersuite: CoreCrypto.CiphersuiteName, credentialType: CoreCrypto.MlsCredentialType) throws -> [Swift.UInt8]
  func newExternalRemoveProposal(conversationId: CoreCrypto.ConversationId, epoch: Swift.UInt64, keyPackageRef: [Swift.UInt8]) throws -> [Swift.UInt8]
  func joinByExternalCommit(publicGroupState: [Swift.UInt8], customConfiguration: CoreCrypto.CustomConfiguration, credentialType: CoreCrypto.MlsCredentialType) throws -> CoreCrypto.ConversationInitBundle
  func mergePendingGroupFromExternalCommit(conversationId: CoreCrypto.ConversationId) throws
  func clearPendingGroupFromExternalCommit(conversationId: CoreCrypto.ConversationId) throws
  func exportGroupState(conversationId: CoreCrypto.ConversationId) throws -> [Swift.UInt8]
  func exportSecretKey(conversationId: CoreCrypto.ConversationId, keyLength: Swift.UInt32) throws -> [Swift.UInt8]
  func getClientIds(conversationId: CoreCrypto.ConversationId) throws -> [CoreCrypto.ClientId]
  func randomBytes(length: Swift.UInt32) throws -> [Swift.UInt8]
  func reseedRng(seed: [Swift.UInt8]) throws
  func commitAccepted(conversationId: CoreCrypto.ConversationId) throws
  func clearPendingProposal(conversationId: CoreCrypto.ConversationId, proposalRef: [Swift.UInt8]) throws
  func clearPendingCommit(conversationId: CoreCrypto.ConversationId) throws
  func proteusInit() throws
  func proteusSessionFromPrekey(sessionId: Swift.String, prekey: [Swift.UInt8]) throws
  func proteusSessionFromMessage(sessionId: Swift.String, envelope: [Swift.UInt8]) throws -> [Swift.UInt8]
  func proteusSessionSave(sessionId: Swift.String) throws
  func proteusSessionDelete(sessionId: Swift.String) throws
  func proteusSessionExists(sessionId: Swift.String) throws -> Swift.Bool
  func proteusDecrypt(sessionId: Swift.String, ciphertext: [Swift.UInt8]) throws -> [Swift.UInt8]
  func proteusEncrypt(sessionId: Swift.String, plaintext: [Swift.UInt8]) throws -> [Swift.UInt8]
  func proteusEncryptBatched(sessionId: [Swift.String], plaintext: [Swift.UInt8]) throws -> [Swift.String : [Swift.UInt8]]
  func proteusNewPrekey(prekeyId: Swift.UInt16) throws -> [Swift.UInt8]
  func proteusNewPrekeyAuto() throws -> CoreCrypto.ProteusAutoPrekeyBundle
  func proteusLastResortPrekey() throws -> [Swift.UInt8]
  func proteusLastResortPrekeyId() throws -> Swift.UInt16
  func proteusFingerprint() throws -> Swift.String
  func proteusFingerprintLocal(sessionId: Swift.String) throws -> Swift.String
  func proteusFingerprintRemote(sessionId: Swift.String) throws -> Swift.String
  func proteusFingerprintPrekeybundle(prekey: [Swift.UInt8]) throws -> Swift.String
  func proteusCryptoboxMigrate(path: Swift.String) throws
  func proteusLastErrorCode() -> Swift.UInt32
  func e2eiNewEnrollment(clientId: Swift.String, displayName: Swift.String, handle: Swift.String, expiryDays: Swift.UInt32, ciphersuite: CoreCrypto.CiphersuiteName) throws -> CoreCrypto.WireE2eIdentity
  func e2eiMlsInit(enrollment: CoreCrypto.WireE2eIdentity, certificateChain: Swift.String) throws
  func e2eiEnrollmentStash(enrollment: CoreCrypto.WireE2eIdentity) throws -> [Swift.UInt8]
  func e2eiEnrollmentStashPop(handle: [Swift.UInt8]) throws -> CoreCrypto.WireE2eIdentity
}
@_hasMissingDesignatedInitializers public class CoreCrypto : CoreCrypto.CoreCryptoProtocol {
  convenience public init(path: Swift.String, key: Swift.String, clientId: CoreCrypto.ClientId, ciphersuites: [CoreCrypto.CiphersuiteName], entropySeed: [Swift.UInt8]?) throws
  @objc deinit
  public static func deferredInit(path: Swift.String, key: Swift.String, ciphersuites: [CoreCrypto.CiphersuiteName], entropySeed: [Swift.UInt8]?) throws -> CoreCrypto.CoreCrypto
  public func mlsInit(clientId: CoreCrypto.ClientId, ciphersuites: [CoreCrypto.CiphersuiteName]) throws
  public func mlsGenerateKeypairs(ciphersuites: [CoreCrypto.CiphersuiteName]) throws -> [[Swift.UInt8]]
  public func mlsInitWithClientId(clientId: CoreCrypto.ClientId, signaturePublicKeys: [[Swift.UInt8]], ciphersuites: [CoreCrypto.CiphersuiteName]) throws
  public func restoreFromDisk() throws
  public func setCallbacks(callbacks: CoreCrypto.CoreCryptoCallbacks) throws
  public func clientPublicKey(ciphersuite: CoreCrypto.CiphersuiteName) throws -> [Swift.UInt8]
  public func clientKeypackages(ciphersuite: CoreCrypto.CiphersuiteName, amountRequested: Swift.UInt32) throws -> [[Swift.UInt8]]
  public func clientValidKeypackagesCount(ciphersuite: CoreCrypto.CiphersuiteName) throws -> Swift.UInt64
  public func createConversation(conversationId: CoreCrypto.ConversationId, config: CoreCrypto.ConversationConfiguration) throws
  public func conversationEpoch(conversationId: CoreCrypto.ConversationId) throws -> Swift.UInt64
  public func conversationExists(conversationId: CoreCrypto.ConversationId) -> Swift.Bool
  public func processWelcomeMessage(welcomeMessage: [Swift.UInt8], customConfiguration: CoreCrypto.CustomConfiguration) throws -> CoreCrypto.ConversationId
  public func addClientsToConversation(conversationId: CoreCrypto.ConversationId, clients: [CoreCrypto.Invitee]) throws -> CoreCrypto.MemberAddedMessages
  public func removeClientsFromConversation(conversationId: CoreCrypto.ConversationId, clients: [CoreCrypto.ClientId]) throws -> CoreCrypto.CommitBundle
  public func markConversationAsChildOf(childId: CoreCrypto.ConversationId, parentId: CoreCrypto.ConversationId) throws
  public func updateKeyingMaterial(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.CommitBundle
  public func commitPendingProposals(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.CommitBundle?
  public func wipeConversation(conversationId: CoreCrypto.ConversationId) throws
  public func decryptMessage(conversationId: CoreCrypto.ConversationId, payload: [Swift.UInt8]) throws -> CoreCrypto.DecryptedMessage
  public func encryptMessage(conversationId: CoreCrypto.ConversationId, message: [Swift.UInt8]) throws -> [Swift.UInt8]
  public func newAddProposal(conversationId: CoreCrypto.ConversationId, keyPackage: [Swift.UInt8]) throws -> CoreCrypto.ProposalBundle
  public func newUpdateProposal(conversationId: CoreCrypto.ConversationId) throws -> CoreCrypto.ProposalBundle
  public func newRemoveProposal(conversationId: CoreCrypto.ConversationId, clientId: CoreCrypto.ClientId) throws -> CoreCrypto.ProposalBundle
  public func newExternalAddProposal(conversationId: CoreCrypto.ConversationId, epoch: Swift.UInt64, ciphersuite: CoreCrypto.CiphersuiteName, credentialType: CoreCrypto.MlsCredentialType) throws -> [Swift.UInt8]
  public func newExternalRemoveProposal(conversationId: CoreCrypto.ConversationId, epoch: Swift.UInt64, keyPackageRef: [Swift.UInt8]) throws -> [Swift.UInt8]
  public func joinByExternalCommit(publicGroupState: [Swift.UInt8], customConfiguration: CoreCrypto.CustomConfiguration, credentialType: CoreCrypto.MlsCredentialType) throws -> CoreCrypto.ConversationInitBundle
  public func mergePendingGroupFromExternalCommit(conversationId: CoreCrypto.ConversationId) throws
  public func clearPendingGroupFromExternalCommit(conversationId: CoreCrypto.ConversationId) throws
  public func exportGroupState(conversationId: CoreCrypto.ConversationId) throws -> [Swift.UInt8]
  public func exportSecretKey(conversationId: CoreCrypto.ConversationId, keyLength: Swift.UInt32) throws -> [Swift.UInt8]
  public func getClientIds(conversationId: CoreCrypto.ConversationId) throws -> [CoreCrypto.ClientId]
  public func randomBytes(length: Swift.UInt32) throws -> [Swift.UInt8]
  public func reseedRng(seed: [Swift.UInt8]) throws
  public func commitAccepted(conversationId: CoreCrypto.ConversationId) throws
  public func clearPendingProposal(conversationId: CoreCrypto.ConversationId, proposalRef: [Swift.UInt8]) throws
  public func clearPendingCommit(conversationId: CoreCrypto.ConversationId) throws
  public func proteusInit() throws
  public func proteusSessionFromPrekey(sessionId: Swift.String, prekey: [Swift.UInt8]) throws
  public func proteusSessionFromMessage(sessionId: Swift.String, envelope: [Swift.UInt8]) throws -> [Swift.UInt8]
  public func proteusSessionSave(sessionId: Swift.String) throws
  public func proteusSessionDelete(sessionId: Swift.String) throws
  public func proteusSessionExists(sessionId: Swift.String) throws -> Swift.Bool
  public func proteusDecrypt(sessionId: Swift.String, ciphertext: [Swift.UInt8]) throws -> [Swift.UInt8]
  public func proteusEncrypt(sessionId: Swift.String, plaintext: [Swift.UInt8]) throws -> [Swift.UInt8]
  public func proteusEncryptBatched(sessionId: [Swift.String], plaintext: [Swift.UInt8]) throws -> [Swift.String : [Swift.UInt8]]
  public func proteusNewPrekey(prekeyId: Swift.UInt16) throws -> [Swift.UInt8]
  public func proteusNewPrekeyAuto() throws -> CoreCrypto.ProteusAutoPrekeyBundle
  public func proteusLastResortPrekey() throws -> [Swift.UInt8]
  public func proteusLastResortPrekeyId() throws -> Swift.UInt16
  public func proteusFingerprint() throws -> Swift.String
  public func proteusFingerprintLocal(sessionId: Swift.String) throws -> Swift.String
  public func proteusFingerprintRemote(sessionId: Swift.String) throws -> Swift.String
  public func proteusFingerprintPrekeybundle(prekey: [Swift.UInt8]) throws -> Swift.String
  public func proteusCryptoboxMigrate(path: Swift.String) throws
  public func proteusLastErrorCode() -> Swift.UInt32
  public func e2eiNewEnrollment(clientId: Swift.String, displayName: Swift.String, handle: Swift.String, expiryDays: Swift.UInt32, ciphersuite: CoreCrypto.CiphersuiteName) throws -> CoreCrypto.WireE2eIdentity
  public func e2eiMlsInit(enrollment: CoreCrypto.WireE2eIdentity, certificateChain: Swift.String) throws
  public func e2eiEnrollmentStash(enrollment: CoreCrypto.WireE2eIdentity) throws -> [Swift.UInt8]
  public func e2eiEnrollmentStashPop(handle: [Swift.UInt8]) throws -> CoreCrypto.WireE2eIdentity
}
public struct FfiConverterTypeCoreCrypto {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.CoreCrypto
  public static func write(_ value: CoreCrypto.CoreCrypto, into buf: inout [Swift.UInt8])
  public static func lift(_ pointer: Swift.UnsafeMutableRawPointer) throws -> CoreCrypto.CoreCrypto
  public static func lower(_ value: CoreCrypto.CoreCrypto) -> Swift.UnsafeMutableRawPointer
}
public protocol WireE2eIdentityProtocol {
  func directoryResponse(directory: [Swift.UInt8]) throws -> CoreCrypto.AcmeDirectory
  func newAccountRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  func newAccountResponse(account: [Swift.UInt8]) throws
  func newOrderRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  func newOrderResponse(order: [Swift.UInt8]) throws -> CoreCrypto.NewAcmeOrder
  func newAuthzRequest(url: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  func newAuthzResponse(authz: [Swift.UInt8]) throws -> CoreCrypto.NewAcmeAuthz
  func createDpopToken(expirySecs: Swift.UInt32, backendNonce: Swift.String) throws -> Swift.String
  func newDpopChallengeRequest(accessToken: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  func newOidcChallengeRequest(idToken: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  func newChallengeResponse(challenge: [Swift.UInt8]) throws
  func checkOrderRequest(orderUrl: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  func checkOrderResponse(order: [Swift.UInt8]) throws -> Swift.String
  func finalizeRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  func finalizeResponse(finalize: [Swift.UInt8]) throws -> Swift.String
  func certificateRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
}
@_hasMissingDesignatedInitializers public class WireE2eIdentity : CoreCrypto.WireE2eIdentityProtocol {
  @objc deinit
  public func directoryResponse(directory: [Swift.UInt8]) throws -> CoreCrypto.AcmeDirectory
  public func newAccountRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func newAccountResponse(account: [Swift.UInt8]) throws
  public func newOrderRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func newOrderResponse(order: [Swift.UInt8]) throws -> CoreCrypto.NewAcmeOrder
  public func newAuthzRequest(url: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func newAuthzResponse(authz: [Swift.UInt8]) throws -> CoreCrypto.NewAcmeAuthz
  public func createDpopToken(expirySecs: Swift.UInt32, backendNonce: Swift.String) throws -> Swift.String
  public func newDpopChallengeRequest(accessToken: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func newOidcChallengeRequest(idToken: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func newChallengeResponse(challenge: [Swift.UInt8]) throws
  public func checkOrderRequest(orderUrl: Swift.String, previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func checkOrderResponse(order: [Swift.UInt8]) throws -> Swift.String
  public func finalizeRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
  public func finalizeResponse(finalize: [Swift.UInt8]) throws -> Swift.String
  public func certificateRequest(previousNonce: Swift.String) throws -> [Swift.UInt8]
}
public struct FfiConverterTypeWireE2eIdentity {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.WireE2eIdentity
  public static func write(_ value: CoreCrypto.WireE2eIdentity, into buf: inout [Swift.UInt8])
  public static func lift(_ pointer: Swift.UnsafeMutableRawPointer) throws -> CoreCrypto.WireE2eIdentity
  public static func lower(_ value: CoreCrypto.WireE2eIdentity) -> Swift.UnsafeMutableRawPointer
}
public struct AcmeChallenge {
  public var delegate: [Swift.UInt8]
  public var url: Swift.String
  public var target: Swift.String
  public init(delegate: [Swift.UInt8], url: Swift.String, target: Swift.String)
}
extension CoreCrypto.AcmeChallenge : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.AcmeChallenge, rhs: CoreCrypto.AcmeChallenge) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeAcmeChallenge {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.AcmeChallenge
  public static func write(_ value: CoreCrypto.AcmeChallenge, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeAcmeChallenge_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.AcmeChallenge
public func FfiConverterTypeAcmeChallenge_lower(_ value: CoreCrypto.AcmeChallenge) -> CoreCrypto.RustBuffer
public struct AcmeDirectory {
  public var newNonce: Swift.String
  public var newAccount: Swift.String
  public var newOrder: Swift.String
  public init(newNonce: Swift.String, newAccount: Swift.String, newOrder: Swift.String)
}
extension CoreCrypto.AcmeDirectory : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.AcmeDirectory, rhs: CoreCrypto.AcmeDirectory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeAcmeDirectory {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.AcmeDirectory
  public static func write(_ value: CoreCrypto.AcmeDirectory, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeAcmeDirectory_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.AcmeDirectory
public func FfiConverterTypeAcmeDirectory_lower(_ value: CoreCrypto.AcmeDirectory) -> CoreCrypto.RustBuffer
public struct CommitBundle {
  public var welcome: [Swift.UInt8]?
  public var commit: [Swift.UInt8]
  public var publicGroupState: CoreCrypto.PublicGroupStateBundle
  public init(welcome: [Swift.UInt8]?, commit: [Swift.UInt8], publicGroupState: CoreCrypto.PublicGroupStateBundle)
}
extension CoreCrypto.CommitBundle : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.CommitBundle, rhs: CoreCrypto.CommitBundle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeCommitBundle {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.CommitBundle
  public static func write(_ value: CoreCrypto.CommitBundle, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeCommitBundle_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.CommitBundle
public func FfiConverterTypeCommitBundle_lower(_ value: CoreCrypto.CommitBundle) -> CoreCrypto.RustBuffer
public struct ConversationConfiguration {
  public var ciphersuite: CoreCrypto.CiphersuiteName?
  public var externalSenders: [[Swift.UInt8]]
  public var custom: CoreCrypto.CustomConfiguration
  public init(ciphersuite: CoreCrypto.CiphersuiteName?, externalSenders: [[Swift.UInt8]], custom: CoreCrypto.CustomConfiguration)
}
extension CoreCrypto.ConversationConfiguration : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.ConversationConfiguration, rhs: CoreCrypto.ConversationConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeConversationConfiguration {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ConversationConfiguration
  public static func write(_ value: CoreCrypto.ConversationConfiguration, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeConversationConfiguration_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.ConversationConfiguration
public func FfiConverterTypeConversationConfiguration_lower(_ value: CoreCrypto.ConversationConfiguration) -> CoreCrypto.RustBuffer
public struct ConversationInitBundle {
  public var conversationId: [Swift.UInt8]
  public var commit: [Swift.UInt8]
  public var publicGroupState: CoreCrypto.PublicGroupStateBundle
  public init(conversationId: [Swift.UInt8], commit: [Swift.UInt8], publicGroupState: CoreCrypto.PublicGroupStateBundle)
}
extension CoreCrypto.ConversationInitBundle : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.ConversationInitBundle, rhs: CoreCrypto.ConversationInitBundle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeConversationInitBundle {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ConversationInitBundle
  public static func write(_ value: CoreCrypto.ConversationInitBundle, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeConversationInitBundle_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.ConversationInitBundle
public func FfiConverterTypeConversationInitBundle_lower(_ value: CoreCrypto.ConversationInitBundle) -> CoreCrypto.RustBuffer
public struct CustomConfiguration {
  public var keyRotationSpan: Foundation.TimeInterval?
  public var wirePolicy: CoreCrypto.MlsWirePolicy?
  public init(keyRotationSpan: Foundation.TimeInterval?, wirePolicy: CoreCrypto.MlsWirePolicy?)
}
extension CoreCrypto.CustomConfiguration : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.CustomConfiguration, rhs: CoreCrypto.CustomConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeCustomConfiguration {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.CustomConfiguration
  public static func write(_ value: CoreCrypto.CustomConfiguration, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeCustomConfiguration_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.CustomConfiguration
public func FfiConverterTypeCustomConfiguration_lower(_ value: CoreCrypto.CustomConfiguration) -> CoreCrypto.RustBuffer
public struct DecryptedMessage {
  public var message: [Swift.UInt8]?
  public var proposals: [CoreCrypto.ProposalBundle]
  public var isActive: Swift.Bool
  public var commitDelay: Swift.UInt64?
  public var senderClientId: CoreCrypto.ClientId?
  public var hasEpochChanged: Swift.Bool
  public var identity: CoreCrypto.WireIdentity?
  public init(message: [Swift.UInt8]?, proposals: [CoreCrypto.ProposalBundle], isActive: Swift.Bool, commitDelay: Swift.UInt64?, senderClientId: CoreCrypto.ClientId?, hasEpochChanged: Swift.Bool, identity: CoreCrypto.WireIdentity?)
}
extension CoreCrypto.DecryptedMessage : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.DecryptedMessage, rhs: CoreCrypto.DecryptedMessage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeDecryptedMessage {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.DecryptedMessage
  public static func write(_ value: CoreCrypto.DecryptedMessage, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeDecryptedMessage_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.DecryptedMessage
public func FfiConverterTypeDecryptedMessage_lower(_ value: CoreCrypto.DecryptedMessage) -> CoreCrypto.RustBuffer
public struct Invitee {
  public var id: CoreCrypto.ClientId
  public var kp: [Swift.UInt8]
  public init(id: CoreCrypto.ClientId, kp: [Swift.UInt8])
}
extension CoreCrypto.Invitee : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.Invitee, rhs: CoreCrypto.Invitee) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeInvitee {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.Invitee
  public static func write(_ value: CoreCrypto.Invitee, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeInvitee_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.Invitee
public func FfiConverterTypeInvitee_lower(_ value: CoreCrypto.Invitee) -> CoreCrypto.RustBuffer
public struct MemberAddedMessages {
  public var commit: [Swift.UInt8]
  public var welcome: [Swift.UInt8]
  public var publicGroupState: CoreCrypto.PublicGroupStateBundle
  public init(commit: [Swift.UInt8], welcome: [Swift.UInt8], publicGroupState: CoreCrypto.PublicGroupStateBundle)
}
extension CoreCrypto.MemberAddedMessages : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.MemberAddedMessages, rhs: CoreCrypto.MemberAddedMessages) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeMemberAddedMessages {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MemberAddedMessages
  public static func write(_ value: CoreCrypto.MemberAddedMessages, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeMemberAddedMessages_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.MemberAddedMessages
public func FfiConverterTypeMemberAddedMessages_lower(_ value: CoreCrypto.MemberAddedMessages) -> CoreCrypto.RustBuffer
public struct NewAcmeAuthz {
  public var identifier: Swift.String
  public var wireDpopChallenge: CoreCrypto.AcmeChallenge?
  public var wireOidcChallenge: CoreCrypto.AcmeChallenge?
  public init(identifier: Swift.String, wireDpopChallenge: CoreCrypto.AcmeChallenge?, wireOidcChallenge: CoreCrypto.AcmeChallenge?)
}
extension CoreCrypto.NewAcmeAuthz : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.NewAcmeAuthz, rhs: CoreCrypto.NewAcmeAuthz) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeNewAcmeAuthz {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.NewAcmeAuthz
  public static func write(_ value: CoreCrypto.NewAcmeAuthz, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeNewAcmeAuthz_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.NewAcmeAuthz
public func FfiConverterTypeNewAcmeAuthz_lower(_ value: CoreCrypto.NewAcmeAuthz) -> CoreCrypto.RustBuffer
public struct NewAcmeOrder {
  public var delegate: [Swift.UInt8]
  public var authorizations: [Swift.String]
  public init(delegate: [Swift.UInt8], authorizations: [Swift.String])
}
extension CoreCrypto.NewAcmeOrder : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.NewAcmeOrder, rhs: CoreCrypto.NewAcmeOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeNewAcmeOrder {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.NewAcmeOrder
  public static func write(_ value: CoreCrypto.NewAcmeOrder, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeNewAcmeOrder_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.NewAcmeOrder
public func FfiConverterTypeNewAcmeOrder_lower(_ value: CoreCrypto.NewAcmeOrder) -> CoreCrypto.RustBuffer
public struct ProposalBundle {
  public var proposal: [Swift.UInt8]
  public var proposalRef: [Swift.UInt8]
  public init(proposal: [Swift.UInt8], proposalRef: [Swift.UInt8])
}
extension CoreCrypto.ProposalBundle : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.ProposalBundle, rhs: CoreCrypto.ProposalBundle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeProposalBundle {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ProposalBundle
  public static func write(_ value: CoreCrypto.ProposalBundle, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeProposalBundle_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.ProposalBundle
public func FfiConverterTypeProposalBundle_lower(_ value: CoreCrypto.ProposalBundle) -> CoreCrypto.RustBuffer
public struct ProteusAutoPrekeyBundle {
  public var id: Swift.UInt16
  public var pkb: [Swift.UInt8]
  public init(id: Swift.UInt16, pkb: [Swift.UInt8])
}
extension CoreCrypto.ProteusAutoPrekeyBundle : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.ProteusAutoPrekeyBundle, rhs: CoreCrypto.ProteusAutoPrekeyBundle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeProteusAutoPrekeyBundle {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ProteusAutoPrekeyBundle
  public static func write(_ value: CoreCrypto.ProteusAutoPrekeyBundle, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeProteusAutoPrekeyBundle_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.ProteusAutoPrekeyBundle
public func FfiConverterTypeProteusAutoPrekeyBundle_lower(_ value: CoreCrypto.ProteusAutoPrekeyBundle) -> CoreCrypto.RustBuffer
public struct PublicGroupStateBundle {
  public var encryptionType: CoreCrypto.MlsPublicGroupStateEncryptionType
  public var ratchetTreeType: CoreCrypto.MlsRatchetTreeType
  public var payload: [Swift.UInt8]
  public init(encryptionType: CoreCrypto.MlsPublicGroupStateEncryptionType, ratchetTreeType: CoreCrypto.MlsRatchetTreeType, payload: [Swift.UInt8])
}
extension CoreCrypto.PublicGroupStateBundle : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.PublicGroupStateBundle, rhs: CoreCrypto.PublicGroupStateBundle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypePublicGroupStateBundle {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.PublicGroupStateBundle
  public static func write(_ value: CoreCrypto.PublicGroupStateBundle, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypePublicGroupStateBundle_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.PublicGroupStateBundle
public func FfiConverterTypePublicGroupStateBundle_lower(_ value: CoreCrypto.PublicGroupStateBundle) -> CoreCrypto.RustBuffer
public struct WireIdentity {
  public var clientId: Swift.String
  public var handle: Swift.String
  public var displayName: Swift.String
  public var domain: Swift.String
  public init(clientId: Swift.String, handle: Swift.String, displayName: Swift.String, domain: Swift.String)
}
extension CoreCrypto.WireIdentity : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: CoreCrypto.WireIdentity, rhs: CoreCrypto.WireIdentity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FfiConverterTypeWireIdentity {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.WireIdentity
  public static func write(_ value: CoreCrypto.WireIdentity, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeWireIdentity_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.WireIdentity
public func FfiConverterTypeWireIdentity_lower(_ value: CoreCrypto.WireIdentity) -> CoreCrypto.RustBuffer
public enum CiphersuiteName {
  case mls128Dhkemx25519Aes128gcmSha256Ed25519
  case mls128Dhkemp256Aes128gcmSha256P256
  case mls128Dhkemx25519Chacha20poly1305Sha256Ed25519
  case mls256Dhkemx448Aes256gcmSha512Ed448
  case mls256Dhkemp521Aes256gcmSha512P521
  case mls256Dhkemx448Chacha20poly1305Sha512Ed448
  case mls256Dhkemp384Aes256gcmSha384P384
}
public struct FfiConverterTypeCiphersuiteName {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.CiphersuiteName
  public static func write(_ value: CoreCrypto.CiphersuiteName, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeCiphersuiteName_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.CiphersuiteName
public func FfiConverterTypeCiphersuiteName_lower(_ value: CoreCrypto.CiphersuiteName) -> CoreCrypto.RustBuffer
extension CoreCrypto.CiphersuiteName : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.CiphersuiteName, b: CoreCrypto.CiphersuiteName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MlsCredentialType {
  case basic
  case x509
}
public struct FfiConverterTypeMlsCredentialType {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MlsCredentialType
  public static func write(_ value: CoreCrypto.MlsCredentialType, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeMlsCredentialType_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.MlsCredentialType
public func FfiConverterTypeMlsCredentialType_lower(_ value: CoreCrypto.MlsCredentialType) -> CoreCrypto.RustBuffer
extension CoreCrypto.MlsCredentialType : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.MlsCredentialType, b: CoreCrypto.MlsCredentialType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MlsPublicGroupStateEncryptionType {
  case plaintext
  case jweEncrypted
}
public struct FfiConverterTypeMlsPublicGroupStateEncryptionType {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MlsPublicGroupStateEncryptionType
  public static func write(_ value: CoreCrypto.MlsPublicGroupStateEncryptionType, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeMlsPublicGroupStateEncryptionType_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.MlsPublicGroupStateEncryptionType
public func FfiConverterTypeMlsPublicGroupStateEncryptionType_lower(_ value: CoreCrypto.MlsPublicGroupStateEncryptionType) -> CoreCrypto.RustBuffer
extension CoreCrypto.MlsPublicGroupStateEncryptionType : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.MlsPublicGroupStateEncryptionType, b: CoreCrypto.MlsPublicGroupStateEncryptionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MlsRatchetTreeType {
  case full
  case delta
  case byRef
}
public struct FfiConverterTypeMlsRatchetTreeType {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MlsRatchetTreeType
  public static func write(_ value: CoreCrypto.MlsRatchetTreeType, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeMlsRatchetTreeType_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.MlsRatchetTreeType
public func FfiConverterTypeMlsRatchetTreeType_lower(_ value: CoreCrypto.MlsRatchetTreeType) -> CoreCrypto.RustBuffer
extension CoreCrypto.MlsRatchetTreeType : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.MlsRatchetTreeType, b: CoreCrypto.MlsRatchetTreeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MlsWirePolicy {
  case plaintext
  case ciphertext
}
public struct FfiConverterTypeMlsWirePolicy {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MlsWirePolicy
  public static func write(_ value: CoreCrypto.MlsWirePolicy, into buf: inout [Swift.UInt8])
}
public func FfiConverterTypeMlsWirePolicy_lift(_ buf: CoreCrypto.RustBuffer) throws -> CoreCrypto.MlsWirePolicy
public func FfiConverterTypeMlsWirePolicy_lower(_ value: CoreCrypto.MlsWirePolicy) -> CoreCrypto.RustBuffer
extension CoreCrypto.MlsWirePolicy : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.MlsWirePolicy, b: CoreCrypto.MlsWirePolicy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CryptoError {
  case ConversationNotFound(message: Swift.String)
  case ClientNotFound(message: Swift.String)
  case PendingProposalNotFound(message: Swift.String)
  case PendingCommitNotFound(message: Swift.String)
  case MalformedIdentifier(message: Swift.String)
  case ClientSignatureNotFound(message: Swift.String)
  case ClientSignatureMismatch(message: Swift.String)
  case LockPoisonError(message: Swift.String)
  case ImplementationError(message: Swift.String)
  case OutOfKeyPackage(message: Swift.String)
  case MlsProviderError(message: Swift.String)
  case KeyStoreError(message: Swift.String)
  case MlsError(message: Swift.String)
  case Utf8Error(message: Swift.String)
  case StringUtf8Error(message: Swift.String)
  case ParseIntError(message: Swift.String)
  case ConvertIntError(message: Swift.String)
  case InvalidByteArrayError(message: Swift.String)
  case IoError(message: Swift.String)
  case Unauthorized(message: Swift.String)
  case CallbacksNotSet(message: Swift.String)
  case UnauthorizedExternalAddProposal(message: Swift.String)
  case UnauthorizedExternalCommit(message: Swift.String)
  case InvalidHashReference(message: Swift.String)
  case GenerationOutOfBound(message: Swift.String)
  case WrongEpoch(message: Swift.String)
  case DecryptionError(message: Swift.String)
  case HexDecodeError(message: Swift.String)
  case ProteusError(message: Swift.String)
  case CryptoboxMigrationError(message: Swift.String)
  case ProteusNotInitialized(message: Swift.String)
  case ProteusSupportNotEnabled(message: Swift.String)
  case MlsNotInitialized(message: Swift.String)
  case InvalidKeyPackage(message: Swift.String)
  case IdentityAlreadyPresent(message: Swift.String)
  case NoProvisionalIdentityFound(message: Swift.String)
  case TooManyIdentitiesPresent(message: Swift.String)
  case ParentGroupNotFound(message: Swift.String)
  case InvalidIdentity(message: Swift.String)
}
public struct FfiConverterTypeCryptoError {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.CryptoError
  public static func write(_ value: CoreCrypto.CryptoError, into buf: inout [Swift.UInt8])
}
extension CoreCrypto.CryptoError : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.CryptoError, b: CoreCrypto.CryptoError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CoreCrypto.CryptoError : Swift.Error {
}
public enum E2eIdentityError {
  case ImplementationError(message: Swift.String)
  case NotYetSupported(message: Swift.String)
  case E2eiInvalidDomain(message: Swift.String)
  case CryptoError(message: Swift.String)
  case IdentityError(message: Swift.String)
  case UrlError(message: Swift.String)
  case JsonError(message: Swift.String)
  case Utf8Error(message: Swift.String)
  case MlsError(message: Swift.String)
  case LockPoisonError(message: Swift.String)
}
public struct FfiConverterTypeE2eIdentityError {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.E2eIdentityError
  public static func write(_ value: CoreCrypto.E2eIdentityError, into buf: inout [Swift.UInt8])
}
extension CoreCrypto.E2eIdentityError : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreCrypto.E2eIdentityError, b: CoreCrypto.E2eIdentityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CoreCrypto.E2eIdentityError : Swift.Error {
}
public protocol CoreCryptoCallbacks : AnyObject {
  func authorize(conversationId: CoreCrypto.ConversationId, clientId: CoreCrypto.ClientId) -> Swift.Bool
  func userAuthorize(conversationId: CoreCrypto.ConversationId, externalClientId: CoreCrypto.ClientId, existingClients: [CoreCrypto.ClientId]) -> Swift.Bool
  func clientIsExistingGroupUser(conversationId: CoreCrypto.ConversationId, clientId: CoreCrypto.ClientId, existingClients: [CoreCrypto.ClientId], parentConversationClients: [CoreCrypto.ClientId]?) -> Swift.Bool
}
public typealias ClientId = [Swift.UInt8]
public struct FfiConverterTypeClientId {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ClientId
  public static func write(_ value: CoreCrypto.ClientId, into buf: inout [Swift.UInt8])
  public static func lift(_ value: CoreCrypto.RustBuffer) throws -> CoreCrypto.ClientId
  public static func lower(_ value: CoreCrypto.ClientId) -> CoreCrypto.RustBuffer
}
public typealias ConversationId = [Swift.UInt8]
public struct FfiConverterTypeConversationId {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.ConversationId
  public static func write(_ value: CoreCrypto.ConversationId, into buf: inout [Swift.UInt8])
  public static func lift(_ value: CoreCrypto.RustBuffer) throws -> CoreCrypto.ConversationId
  public static func lower(_ value: CoreCrypto.ConversationId) -> CoreCrypto.RustBuffer
}
public typealias MemberId = [Swift.UInt8]
public struct FfiConverterTypeMemberId {
  public static func read(from buf: inout (data: Foundation.Data, offset: Foundation.Data.Index)) throws -> CoreCrypto.MemberId
  public static func write(_ value: CoreCrypto.MemberId, into buf: inout [Swift.UInt8])
  public static func lift(_ value: CoreCrypto.RustBuffer) throws -> CoreCrypto.MemberId
  public static func lower(_ value: CoreCrypto.MemberId) -> CoreCrypto.RustBuffer
}
public func version() -> Swift.String
public enum CoreCryptoLifecycle {
}
