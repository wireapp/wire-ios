//
// Wire
// Copyright (C) 2019 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
//

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ClientAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case resetSession // = 0

  public init() {
    self = .resetSession
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resetSession
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .resetSession: return 0
    }
  }

}

#if swift(>=4.2)

extension ClientAction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum EncryptionAlgorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case aesCbc // = 0
  case aesGcm // = 1

  public init() {
    self = .aesCbc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aesCbc
    case 1: self = .aesGcm
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .aesCbc: return 0
    case .aesGcm: return 1
    }
  }

}

#if swift(>=4.2)

extension EncryptionAlgorithm: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum LegalHoldStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case disabled // = 0
  case enabled // = 1

  public init() {
    self = .disabled
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disabled
    case 1: self = .enabled
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .disabled: return 0
    case .enabled: return 1
    }
  }

}

#if swift(>=4.2)

extension LegalHoldStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct GenericMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// client generated random id, preferably UUID
  public var messageID: String {
    get {return _storage._messageID ?? String()}
    set {_uniqueStorage()._messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return _storage._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {_uniqueStorage()._messageID = nil}

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  /// deprecated in favour of Asset
  public var image: ImageAsset {
    get {
      if case .image(let v)? = _storage._content {return v}
      return ImageAsset()
    }
    set {_uniqueStorage()._content = .image(newValue)}
  }

  public var knock: Knock {
    get {
      if case .knock(let v)? = _storage._content {return v}
      return Knock()
    }
    set {_uniqueStorage()._content = .knock(newValue)}
  }

  public var lastRead: LastRead {
    get {
      if case .lastRead(let v)? = _storage._content {return v}
      return LastRead()
    }
    set {_uniqueStorage()._content = .lastRead(newValue)}
  }

  public var cleared: Cleared {
    get {
      if case .cleared(let v)? = _storage._content {return v}
      return Cleared()
    }
    set {_uniqueStorage()._content = .cleared(newValue)}
  }

  public var external: External {
    get {
      if case .external(let v)? = _storage._content {return v}
      return External()
    }
    set {_uniqueStorage()._content = .external(newValue)}
  }

  public var clientAction: ClientAction {
    get {
      if case .clientAction(let v)? = _storage._content {return v}
      return .resetSession
    }
    set {_uniqueStorage()._content = .clientAction(newValue)}
  }

  public var calling: Calling {
    get {
      if case .calling(let v)? = _storage._content {return v}
      return Calling()
    }
    set {_uniqueStorage()._content = .calling(newValue)}
  }

  public var asset: Asset {
    get {
      if case .asset(let v)? = _storage._content {return v}
      return Asset()
    }
    set {_uniqueStorage()._content = .asset(newValue)}
  }

  public var hidden: MessageHide {
    get {
      if case .hidden(let v)? = _storage._content {return v}
      return MessageHide()
    }
    set {_uniqueStorage()._content = .hidden(newValue)}
  }

  public var location: Location {
    get {
      if case .location(let v)? = _storage._content {return v}
      return Location()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  public var deleted: MessageDelete {
    get {
      if case .deleted(let v)? = _storage._content {return v}
      return MessageDelete()
    }
    set {_uniqueStorage()._content = .deleted(newValue)}
  }

  public var edited: MessageEdit {
    get {
      if case .edited(let v)? = _storage._content {return v}
      return MessageEdit()
    }
    set {_uniqueStorage()._content = .edited(newValue)}
  }

  public var confirmation: Confirmation {
    get {
      if case .confirmation(let v)? = _storage._content {return v}
      return Confirmation()
    }
    set {_uniqueStorage()._content = .confirmation(newValue)}
  }

  public var reaction: Reaction {
    get {
      if case .reaction(let v)? = _storage._content {return v}
      return Reaction()
    }
    set {_uniqueStorage()._content = .reaction(newValue)}
  }

  public var ephemeral: Ephemeral {
    get {
      if case .ephemeral(let v)? = _storage._content {return v}
      return Ephemeral()
    }
    set {_uniqueStorage()._content = .ephemeral(newValue)}
  }

  public var availability: Availability {
    get {
      if case .availability(let v)? = _storage._content {return v}
      return Availability()
    }
    set {_uniqueStorage()._content = .availability(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case text(Text)
    /// deprecated in favour of Asset
    case image(ImageAsset)
    case knock(Knock)
    case lastRead(LastRead)
    case cleared(Cleared)
    case external(External)
    case clientAction(ClientAction)
    case calling(Calling)
    case asset(Asset)
    case hidden(MessageHide)
    case location(Location)
    case deleted(MessageDelete)
    case edited(MessageEdit)
    case confirmation(Confirmation)
    case reaction(Reaction)
    case ephemeral(Ephemeral)
    case availability(Availability)

  #if !swift(>=4.1)
    public static func ==(lhs: GenericMessage.OneOf_Content, rhs: GenericMessage.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.image(let l), .image(let r)): return l == r
      case (.knock(let l), .knock(let r)): return l == r
      case (.lastRead(let l), .lastRead(let r)): return l == r
      case (.cleared(let l), .cleared(let r)): return l == r
      case (.external(let l), .external(let r)): return l == r
      case (.clientAction(let l), .clientAction(let r)): return l == r
      case (.calling(let l), .calling(let r)): return l == r
      case (.asset(let l), .asset(let r)): return l == r
      case (.hidden(let l), .hidden(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      case (.deleted(let l), .deleted(let r)): return l == r
      case (.edited(let l), .edited(let r)): return l == r
      case (.confirmation(let l), .confirmation(let r)): return l == r
      case (.reaction(let l), .reaction(let r)): return l == r
      case (.ephemeral(let l), .ephemeral(let r)): return l == r
      case (.availability(let l), .availability(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Availability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Availability.TypeEnum {
    get {return _type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0
    case available // = 1
    case away // = 2
    case busy // = 3

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .available
      case 2: self = .away
      case 3: self = .busy
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .available: return 1
      case .away: return 2
      case .busy: return 3
      }
    }

  }

  public init() {}

  fileprivate var _type: Availability.TypeEnum? = nil
}

#if swift(>=4.2)

extension Availability.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Ephemeral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expireAfterMillis: Int64 {
    get {return _storage._expireAfterMillis ?? 0}
    set {_uniqueStorage()._expireAfterMillis = newValue}
  }
  /// Returns true if `expireAfterMillis` has been explicitly set.
  public var hasExpireAfterMillis: Bool {return _storage._expireAfterMillis != nil}
  /// Clears the value of `expireAfterMillis`. Subsequent reads from it will return its default value.
  public mutating func clearExpireAfterMillis() {_uniqueStorage()._expireAfterMillis = nil}

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  /// deprecated in favour of Asset
  public var image: ImageAsset {
    get {
      if case .image(let v)? = _storage._content {return v}
      return ImageAsset()
    }
    set {_uniqueStorage()._content = .image(newValue)}
  }

  public var knock: Knock {
    get {
      if case .knock(let v)? = _storage._content {return v}
      return Knock()
    }
    set {_uniqueStorage()._content = .knock(newValue)}
  }

  public var asset: Asset {
    get {
      if case .asset(let v)? = _storage._content {return v}
      return Asset()
    }
    set {_uniqueStorage()._content = .asset(newValue)}
  }

  public var location: Location {
    get {
      if case .location(let v)? = _storage._content {return v}
      return Location()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case text(Text)
    /// deprecated in favour of Asset
    case image(ImageAsset)
    case knock(Knock)
    case asset(Asset)
    case location(Location)

  #if !swift(>=4.1)
    public static func ==(lhs: Ephemeral.OneOf_Content, rhs: Ephemeral.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.image(let l), .image(let r)): return l == r
      case (.knock(let l), .knock(let r)): return l == r
      case (.asset(let l), .asset(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String {
    get {return _storage._content ?? String()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {_uniqueStorage()._content = nil}

  /// reserved 2; // reserved keyword is not available in older protoc versions
  public var linkPreview: [LinkPreview] {
    get {return _storage._linkPreview}
    set {_uniqueStorage()._linkPreview = newValue}
  }

  public var mentions: [Mention] {
    get {return _storage._mentions}
    set {_uniqueStorage()._mentions = newValue}
  }

  /// if this Text is part of a MessageEdit, this field is ignored
  public var quote: Quote {
    get {return _storage._quote ?? Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  public var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  public mutating func clearQuote() {_uniqueStorage()._quote = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _storage._expectsReadConfirmation ?? false}
    set {_uniqueStorage()._expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return _storage._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {_uniqueStorage()._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _storage._legalHoldStatus ?? .disabled}
    set {_uniqueStorage()._legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return _storage._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {_uniqueStorage()._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Knock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hotKnock: Bool {
    get {return _hotKnock ?? false}
    set {_hotKnock = newValue}
  }
  /// Returns true if `hotKnock` has been explicitly set.
  public var hasHotKnock: Bool {return self._hotKnock != nil}
  /// Clears the value of `hotKnock`. Subsequent reads from it will return its default value.
  public mutating func clearHotKnock() {self._hotKnock = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .disabled}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hotKnock: Bool? = nil
  fileprivate var _expectsReadConfirmation: Bool? = nil
  fileprivate var _legalHoldStatus: LegalHoldStatus? = nil
}

public struct LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {_uniqueStorage()._url = nil}

  /// url offset from beginning of text message
  public var urlOffset: Int32 {
    get {return _storage._urlOffset ?? 0}
    set {_uniqueStorage()._urlOffset = newValue}
  }
  /// Returns true if `urlOffset` has been explicitly set.
  public var hasURLOffset: Bool {return _storage._urlOffset != nil}
  /// Clears the value of `urlOffset`. Subsequent reads from it will return its default value.
  public mutating func clearURLOffset() {_uniqueStorage()._urlOffset = nil}

  public var preview: OneOf_Preview? {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  /// deprecated - use meta_data
  public var article: Article {
    get {
      if case .article(let v)? = _storage._preview {return v}
      return Article()
    }
    set {_uniqueStorage()._preview = .article(newValue)}
  }

  public var permanentURL: String {
    get {return _storage._permanentURL ?? String()}
    set {_uniqueStorage()._permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  public var hasPermanentURL: Bool {return _storage._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  public mutating func clearPermanentURL() {_uniqueStorage()._permanentURL = nil}

  public var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var summary: String {
    get {return _storage._summary ?? String()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var image: Asset {
    get {return _storage._image ?? Asset()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var metaData: OneOf_MetaData? {
    get {return _storage._metaData}
    set {_uniqueStorage()._metaData = newValue}
  }

  public var tweet: Tweet {
    get {
      if case .tweet(let v)? = _storage._metaData {return v}
      return Tweet()
    }
    set {_uniqueStorage()._metaData = .tweet(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Preview: Equatable {
    /// deprecated - use meta_data
    case article(Article)

  #if !swift(>=4.1)
    public static func ==(lhs: LinkPreview.OneOf_Preview, rhs: LinkPreview.OneOf_Preview) -> Bool {
      switch (lhs, rhs) {
      case (.article(let l), .article(let r)): return l == r
      }
    }
  #endif
  }

  public enum OneOf_MetaData: Equatable {
    case tweet(Tweet)

  #if !swift(>=4.1)
    public static func ==(lhs: LinkPreview.OneOf_MetaData, rhs: LinkPreview.OneOf_MetaData) -> Bool {
      switch (lhs, rhs) {
      case (.tweet(let l), .tweet(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tweet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _author: String? = nil
  fileprivate var _username: String? = nil
}

/// deprecated - use the additional fields in LinkPreview
public struct Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var permanentURL: String {
    get {return _storage._permanentURL ?? String()}
    set {_uniqueStorage()._permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  public var hasPermanentURL: Bool {return _storage._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  public mutating func clearPermanentURL() {_uniqueStorage()._permanentURL = nil}

  public var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var summary: String {
    get {return _storage._summary ?? String()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var image: Asset {
    get {return _storage._image ?? Asset()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Mention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// offset from beginning of the message counting in utf16 characters
  public var start: Int32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var length: Int32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  public var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  public mutating func clearLength() {self._length = nil}

  public var mentionType: Mention.OneOf_MentionType? = nil

  public var userID: String {
    get {
      if case .userID(let v)? = mentionType {return v}
      return String()
    }
    set {mentionType = .userID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MentionType: Equatable {
    case userID(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Mention.OneOf_MentionType, rhs: Mention.OneOf_MentionType) -> Bool {
      switch (lhs, rhs) {
      case (.userID(let l), .userID(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _start: Int32? = nil
  fileprivate var _length: Int32? = nil
}

public struct LastRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var lastReadTimestamp: Int64 {
    get {return _lastReadTimestamp ?? 0}
    set {_lastReadTimestamp = newValue}
  }
  /// Returns true if `lastReadTimestamp` has been explicitly set.
  public var hasLastReadTimestamp: Bool {return self._lastReadTimestamp != nil}
  /// Clears the value of `lastReadTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearLastReadTimestamp() {self._lastReadTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _lastReadTimestamp: Int64? = nil
}

public struct Cleared {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var clearedTimestamp: Int64 {
    get {return _clearedTimestamp ?? 0}
    set {_clearedTimestamp = newValue}
  }
  /// Returns true if `clearedTimestamp` has been explicitly set.
  public var hasClearedTimestamp: Bool {return self._clearedTimestamp != nil}
  /// Clears the value of `clearedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearClearedTimestamp() {self._clearedTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _clearedTimestamp: Int64? = nil
}

public struct MessageHide {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _messageID: String? = nil
}

public struct MessageDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: String? = nil
}

public struct MessageEdit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replacingMessageID: String {
    get {return _storage._replacingMessageID ?? String()}
    set {_uniqueStorage()._replacingMessageID = newValue}
  }
  /// Returns true if `replacingMessageID` has been explicitly set.
  public var hasReplacingMessageID: Bool {return _storage._replacingMessageID != nil}
  /// Clears the value of `replacingMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearReplacingMessageID() {_uniqueStorage()._replacingMessageID = nil}

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Reply can also be edited, but the edit will only affect the Text part
  public var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    /// Reply can also be edited, but the edit will only affect the Text part
    case text(Text)

  #if !swift(>=4.1)
    public static func ==(lhs: MessageEdit.OneOf_Content, rhs: MessageEdit.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quotedMessageID: String {
    get {return _quotedMessageID ?? String()}
    set {_quotedMessageID = newValue}
  }
  /// Returns true if `quotedMessageID` has been explicitly set.
  public var hasQuotedMessageID: Bool {return self._quotedMessageID != nil}
  /// Clears the value of `quotedMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearQuotedMessageID() {self._quotedMessageID = nil}

  public var quotedMessageSha256: Data {
    get {return _quotedMessageSha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_quotedMessageSha256 = newValue}
  }
  /// Returns true if `quotedMessageSha256` has been explicitly set.
  public var hasQuotedMessageSha256: Bool {return self._quotedMessageSha256 != nil}
  /// Clears the value of `quotedMessageSha256`. Subsequent reads from it will return its default value.
  public mutating func clearQuotedMessageSha256() {self._quotedMessageSha256 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _quotedMessageID: String? = nil
  fileprivate var _quotedMessageSha256: Data? = nil
}

public struct Confirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Confirmation.TypeEnum {
    get {return _type ?? .delivered}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var firstMessageID: String {
    get {return _firstMessageID ?? String()}
    set {_firstMessageID = newValue}
  }
  /// Returns true if `firstMessageID` has been explicitly set.
  public var hasFirstMessageID: Bool {return self._firstMessageID != nil}
  /// Clears the value of `firstMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearFirstMessageID() {self._firstMessageID = nil}

  public var moreMessageIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case delivered // = 0
    case read // = 1

    public init() {
      self = .delivered
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delivered
      case 1: self = .read
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .delivered: return 0
      case .read: return 1
      }
    }

  }

  public init() {}

  fileprivate var _type: Confirmation.TypeEnum? = nil
  fileprivate var _firstMessageID: String? = nil
}

#if swift(>=4.2)

extension Confirmation.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  public var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  /// location description/name
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// google maps zoom level (check maps api documentation)
  public var zoom: Int32 {
    get {return _zoom ?? 0}
    set {_zoom = newValue}
  }
  /// Returns true if `zoom` has been explicitly set.
  public var hasZoom: Bool {return self._zoom != nil}
  /// Clears the value of `zoom`. Subsequent reads from it will return its default value.
  public mutating func clearZoom() {self._zoom = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .disabled}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _longitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _name: String? = nil
  fileprivate var _zoom: Int32? = nil
  fileprivate var _expectsReadConfirmation: Bool? = nil
  fileprivate var _legalHoldStatus: LegalHoldStatus? = nil
}

/// deprecated in favour of Asset.Original.ImageMetaData
public struct ImageAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: String {
    get {return _tag ?? String()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {self._tag = nil}

  public var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  public var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  public mutating func clearWidth() {self._width = nil}

  public var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  public var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  public mutating func clearHeight() {self._height = nil}

  public var originalWidth: Int32 {
    get {return _originalWidth ?? 0}
    set {_originalWidth = newValue}
  }
  /// Returns true if `originalWidth` has been explicitly set.
  public var hasOriginalWidth: Bool {return self._originalWidth != nil}
  /// Clears the value of `originalWidth`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalWidth() {self._originalWidth = nil}

  public var originalHeight: Int32 {
    get {return _originalHeight ?? 0}
    set {_originalHeight = newValue}
  }
  /// Returns true if `originalHeight` has been explicitly set.
  public var hasOriginalHeight: Bool {return self._originalHeight != nil}
  /// Clears the value of `originalHeight`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalHeight() {self._originalHeight = nil}

  public var mimeType: String {
    get {return _mimeType ?? String()}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  public var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  public mutating func clearMimeType() {self._mimeType = nil}

  public var size: Int32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var otrKey: Data {
    get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  public var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  public mutating func clearOtrKey() {self._otrKey = nil}

  /// deprecated - use sha256
  public var macKey: Data {
    get {return _macKey ?? SwiftProtobuf.Internal.emptyData}
    set {_macKey = newValue}
  }
  /// Returns true if `macKey` has been explicitly set.
  public var hasMacKey: Bool {return self._macKey != nil}
  /// Clears the value of `macKey`. Subsequent reads from it will return its default value.
  public mutating func clearMacKey() {self._macKey = nil}

  /// deprecated - use sha256
  public var mac: Data {
    get {return _mac ?? SwiftProtobuf.Internal.emptyData}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  public var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  public mutating func clearMac() {self._mac = nil}

  /// sha256 of ciphertext
  public var sha256: Data {
    get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  public var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  public mutating func clearSha256() {self._sha256 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tag: String? = nil
  fileprivate var _width: Int32? = nil
  fileprivate var _height: Int32? = nil
  fileprivate var _originalWidth: Int32? = nil
  fileprivate var _originalHeight: Int32? = nil
  fileprivate var _mimeType: String? = nil
  fileprivate var _size: Int32? = nil
  fileprivate var _otrKey: Data? = nil
  fileprivate var _macKey: Data? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _sha256: Data? = nil
}

public struct Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var original: Asset.Original {
    get {return _storage._original ?? Asset.Original()}
    set {_uniqueStorage()._original = newValue}
  }
  /// Returns true if `original` has been explicitly set.
  public var hasOriginal: Bool {return _storage._original != nil}
  /// Clears the value of `original`. Subsequent reads from it will return its default value.
  public mutating func clearOriginal() {_uniqueStorage()._original = nil}

  /// optional Preview preview = 2;  // deprecated - preview was completely replaced
  public var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var notUploaded: Asset.NotUploaded {
    get {
      if case .notUploaded(let v)? = _storage._status {return v}
      return .cancelled
    }
    set {_uniqueStorage()._status = .notUploaded(newValue)}
  }

  public var uploaded: Asset.RemoteData {
    get {
      if case .uploaded(let v)? = _storage._status {return v}
      return Asset.RemoteData()
    }
    set {_uniqueStorage()._status = .uploaded(newValue)}
  }

  public var preview: Asset.Preview {
    get {return _storage._preview ?? Asset.Preview()}
    set {_uniqueStorage()._preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  public var hasPreview: Bool {return _storage._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  public mutating func clearPreview() {_uniqueStorage()._preview = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _storage._expectsReadConfirmation ?? false}
    set {_uniqueStorage()._expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return _storage._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {_uniqueStorage()._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _storage._legalHoldStatus ?? .disabled}
    set {_uniqueStorage()._legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return _storage._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {_uniqueStorage()._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// optional Preview preview = 2;  // deprecated - preview was completely replaced
  public enum OneOf_Status: Equatable {
    case notUploaded(Asset.NotUploaded)
    case uploaded(Asset.RemoteData)

  #if !swift(>=4.1)
    public static func ==(lhs: Asset.OneOf_Status, rhs: Asset.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.notUploaded(let l), .notUploaded(let r)): return l == r
      case (.uploaded(let l), .uploaded(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum NotUploaded: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case cancelled // = 0
    case failed // = 1

    public init() {
      self = .cancelled
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cancelled
      case 1: self = .failed
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .cancelled: return 0
      case .failed: return 1
      }
    }

  }

  public struct Original {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mimeType: String {
      get {return _storage._mimeType ?? String()}
      set {_uniqueStorage()._mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    public var hasMimeType: Bool {return _storage._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    public mutating func clearMimeType() {_uniqueStorage()._mimeType = nil}

    public var size: UInt64 {
      get {return _storage._size ?? 0}
      set {_uniqueStorage()._size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return _storage._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {_uniqueStorage()._size = nil}

    public var name: String {
      get {return _storage._name ?? String()}
      set {_uniqueStorage()._name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return _storage._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {_uniqueStorage()._name = nil}

    public var metaData: OneOf_MetaData? {
      get {return _storage._metaData}
      set {_uniqueStorage()._metaData = newValue}
    }

    public var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = _storage._metaData {return v}
        return Asset.ImageMetaData()
      }
      set {_uniqueStorage()._metaData = .image(newValue)}
    }

    public var video: Asset.VideoMetaData {
      get {
        if case .video(let v)? = _storage._metaData {return v}
        return Asset.VideoMetaData()
      }
      set {_uniqueStorage()._metaData = .video(newValue)}
    }

    public var audio: Asset.AudioMetaData {
      get {
        if case .audio(let v)? = _storage._metaData {return v}
        return Asset.AudioMetaData()
      }
      set {_uniqueStorage()._metaData = .audio(newValue)}
    }

    /// link to source e.g. http://giphy.com/234245
    public var source: String {
      get {return _storage._source ?? String()}
      set {_uniqueStorage()._source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    public var hasSource: Bool {return _storage._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    public mutating func clearSource() {_uniqueStorage()._source = nil}

    /// caption of the asset, e.g. "dog" for a Giphy "dog" search result
    public var caption: String {
      get {return _storage._caption ?? String()}
      set {_uniqueStorage()._caption = newValue}
    }
    /// Returns true if `caption` has been explicitly set.
    public var hasCaption: Bool {return _storage._caption != nil}
    /// Clears the value of `caption`. Subsequent reads from it will return its default value.
    public mutating func clearCaption() {_uniqueStorage()._caption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)
      case video(Asset.VideoMetaData)
      case audio(Asset.AudioMetaData)

    #if !swift(>=4.1)
      public static func ==(lhs: Asset.Original.OneOf_MetaData, rhs: Asset.Original.OneOf_MetaData) -> Bool {
        switch (lhs, rhs) {
        case (.image(let l), .image(let r)): return l == r
        case (.video(let l), .video(let r)): return l == r
        case (.audio(let l), .audio(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Preview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mimeType: String {
      get {return _storage._mimeType ?? String()}
      set {_uniqueStorage()._mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    public var hasMimeType: Bool {return _storage._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    public mutating func clearMimeType() {_uniqueStorage()._mimeType = nil}

    public var size: UInt64 {
      get {return _storage._size ?? 0}
      set {_uniqueStorage()._size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return _storage._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {_uniqueStorage()._size = nil}

    public var remote: Asset.RemoteData {
      get {return _storage._remote ?? Asset.RemoteData()}
      set {_uniqueStorage()._remote = newValue}
    }
    /// Returns true if `remote` has been explicitly set.
    public var hasRemote: Bool {return _storage._remote != nil}
    /// Clears the value of `remote`. Subsequent reads from it will return its default value.
    public mutating func clearRemote() {_uniqueStorage()._remote = nil}

    public var metaData: OneOf_MetaData? {
      get {return _storage._metaData}
      set {_uniqueStorage()._metaData = newValue}
    }

    public var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = _storage._metaData {return v}
        return Asset.ImageMetaData()
      }
      set {_uniqueStorage()._metaData = .image(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)

    #if !swift(>=4.1)
      public static func ==(lhs: Asset.Preview.OneOf_MetaData, rhs: Asset.Preview.OneOf_MetaData) -> Bool {
        switch (lhs, rhs) {
        case (.image(let l), .image(let r)): return l == r
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ImageMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    public var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    public mutating func clearWidth() {self._width = nil}

    public var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    public var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    public mutating func clearHeight() {self._height = nil}

    public var tag: String {
      get {return _tag ?? String()}
      set {_tag = newValue}
    }
    /// Returns true if `tag` has been explicitly set.
    public var hasTag: Bool {return self._tag != nil}
    /// Clears the value of `tag`. Subsequent reads from it will return its default value.
    public mutating func clearTag() {self._tag = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _width: Int32? = nil
    fileprivate var _height: Int32? = nil
    fileprivate var _tag: String? = nil
  }

  public struct VideoMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    public var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    public mutating func clearWidth() {self._width = nil}

    public var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    public var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    public mutating func clearHeight() {self._height = nil}

    public var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    public var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    public mutating func clearDurationInMillis() {self._durationInMillis = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _width: Int32? = nil
    fileprivate var _height: Int32? = nil
    fileprivate var _durationInMillis: UInt64? = nil
  }

  public struct AudioMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    public var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    public mutating func clearDurationInMillis() {self._durationInMillis = nil}

    /// repeated float normalized_loudness = 2 [packed=true]; // deprecated - Switched to bytes instead
    public var normalizedLoudness: Data {
      get {return _normalizedLoudness ?? SwiftProtobuf.Internal.emptyData}
      set {_normalizedLoudness = newValue}
    }
    /// Returns true if `normalizedLoudness` has been explicitly set.
    public var hasNormalizedLoudness: Bool {return self._normalizedLoudness != nil}
    /// Clears the value of `normalizedLoudness`. Subsequent reads from it will return its default value.
    public mutating func clearNormalizedLoudness() {self._normalizedLoudness = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _durationInMillis: UInt64? = nil
    fileprivate var _normalizedLoudness: Data? = nil
  }

  public struct RemoteData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var otrKey: Data {
      get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
      set {_otrKey = newValue}
    }
    /// Returns true if `otrKey` has been explicitly set.
    public var hasOtrKey: Bool {return self._otrKey != nil}
    /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
    public mutating func clearOtrKey() {self._otrKey = nil}

    /// obsolete but required for backward compatibility
    public var sha256: Data {
      get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
      set {_sha256 = newValue}
    }
    /// Returns true if `sha256` has been explicitly set.
    public var hasSha256: Bool {return self._sha256 != nil}
    /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
    public mutating func clearSha256() {self._sha256 = nil}

    public var assetID: String {
      get {return _assetID ?? String()}
      set {_assetID = newValue}
    }
    /// Returns true if `assetID` has been explicitly set.
    public var hasAssetID: Bool {return self._assetID != nil}
    /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
    public mutating func clearAssetID() {self._assetID = nil}

    /// optional bytes asset_token = 4; // deprecated - changed type to string
    public var assetToken: String {
      get {return _assetToken ?? String()}
      set {_assetToken = newValue}
    }
    /// Returns true if `assetToken` has been explicitly set.
    public var hasAssetToken: Bool {return self._assetToken != nil}
    /// Clears the value of `assetToken`. Subsequent reads from it will return its default value.
    public mutating func clearAssetToken() {self._assetToken = nil}

    public var encryption: EncryptionAlgorithm {
      get {return _encryption ?? .aesCbc}
      set {_encryption = newValue}
    }
    /// Returns true if `encryption` has been explicitly set.
    public var hasEncryption: Bool {return self._encryption != nil}
    /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
    public mutating func clearEncryption() {self._encryption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _otrKey: Data? = nil
    fileprivate var _sha256: Data? = nil
    fileprivate var _assetID: String? = nil
    fileprivate var _assetToken: String? = nil
    fileprivate var _encryption: EncryptionAlgorithm? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Asset.NotUploaded: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Actual message is encrypted with AES and sent as additional data
public struct External {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var otrKey: Data {
    get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  public var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  public mutating func clearOtrKey() {self._otrKey = nil}

  /// sha256 of ciphertext, obsolete but required for backward compatibility
  public var sha256: Data {
    get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  public var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  public mutating func clearSha256() {self._sha256 = nil}

  public var encryption: EncryptionAlgorithm {
    get {return _encryption ?? .aesCbc}
    set {_encryption = newValue}
  }
  /// Returns true if `encryption` has been explicitly set.
  public var hasEncryption: Bool {return self._encryption != nil}
  /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
  public mutating func clearEncryption() {self._encryption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _otrKey: Data? = nil
  fileprivate var _sha256: Data? = nil
  fileprivate var _encryption: EncryptionAlgorithm? = nil
}

public struct Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// some emoji reaction or the empty string to remove previous reaction(s)
  public var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _emoji: String? = nil
  fileprivate var _messageID: String? = nil
}

public struct Calling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String {
    get {return _content ?? String()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ClientAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESET_SESSION"),
  ]
}

extension EncryptionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AES_CBC"),
    1: .same(proto: "AES_GCM"),
  ]
}

extension LegalHoldStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "ENABLED"),
  ]
}

extension GenericMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GenericMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    6: .same(proto: "lastRead"),
    7: .same(proto: "cleared"),
    8: .same(proto: "external"),
    9: .same(proto: "clientAction"),
    10: .same(proto: "calling"),
    11: .same(proto: "asset"),
    12: .same(proto: "hidden"),
    13: .same(proto: "location"),
    14: .same(proto: "deleted"),
    15: .same(proto: "edited"),
    16: .same(proto: "confirmation"),
    17: .same(proto: "reaction"),
    18: .same(proto: "ephemeral"),
    19: .same(proto: "availability"),
  ]

  fileprivate class _StorageClass {
    var _messageID: String? = nil
    var _content: GenericMessage.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._messageID == nil {return false}
      switch _storage._content {
      case .text(let v)?: if !v.isInitialized {return false}
      case .image(let v)?: if !v.isInitialized {return false}
      case .knock(let v)?: if !v.isInitialized {return false}
      case .lastRead(let v)?: if !v.isInitialized {return false}
      case .cleared(let v)?: if !v.isInitialized {return false}
      case .external(let v)?: if !v.isInitialized {return false}
      case .calling(let v)?: if !v.isInitialized {return false}
      case .asset(let v)?: if !v.isInitialized {return false}
      case .hidden(let v)?: if !v.isInitialized {return false}
      case .location(let v)?: if !v.isInitialized {return false}
      case .deleted(let v)?: if !v.isInitialized {return false}
      case .edited(let v)?: if !v.isInitialized {return false}
      case .confirmation(let v)?: if !v.isInitialized {return false}
      case .reaction(let v)?: if !v.isInitialized {return false}
      case .ephemeral(let v)?: if !v.isInitialized {return false}
      case .availability(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 3:
          var v: ImageAsset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .image(v)}
        case 4:
          var v: Knock?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .knock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .knock(v)}
        case 6:
          var v: LastRead?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .lastRead(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .lastRead(v)}
        case 7:
          var v: Cleared?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .cleared(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .cleared(v)}
        case 8:
          var v: External?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .external(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .external(v)}
        case 9:
          if _storage._content != nil {try decoder.handleConflictingOneOf()}
          var v: ClientAction?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._content = .clientAction(v)}
        case 10:
          var v: Calling?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .calling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .calling(v)}
        case 11:
          var v: Asset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .asset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .asset(v)}
        case 12:
          var v: MessageHide?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .hidden(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .hidden(v)}
        case 13:
          var v: Location?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .location(v)}
        case 14:
          var v: MessageDelete?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .deleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .deleted(v)}
        case 15:
          var v: MessageEdit?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .edited(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .edited(v)}
        case 16:
          var v: Confirmation?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .confirmation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .confirmation(v)}
        case 17:
          var v: Reaction?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .reaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .reaction(v)}
        case 18:
          var v: Ephemeral?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .ephemeral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .ephemeral(v)}
        case 19:
          var v: Availability?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .availability(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .availability(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._messageID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      switch _storage._content {
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .knock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .lastRead(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .cleared(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .external(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .clientAction(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      case .calling(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .asset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .hidden(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .deleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .edited(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .confirmation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .reaction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .ephemeral(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .availability(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenericMessage, rhs: GenericMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Availability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Availability, rhs: Availability) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "AVAILABLE"),
    2: .same(proto: "AWAY"),
    3: .same(proto: "BUSY"),
  ]
}

extension Ephemeral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ephemeral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expire_after_millis"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    5: .same(proto: "asset"),
    6: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _expireAfterMillis: Int64? = nil
    var _content: Ephemeral.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expireAfterMillis = source._expireAfterMillis
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._expireAfterMillis == nil {return false}
      switch _storage._content {
      case .text(let v)?: if !v.isInitialized {return false}
      case .image(let v)?: if !v.isInitialized {return false}
      case .knock(let v)?: if !v.isInitialized {return false}
      case .asset(let v)?: if !v.isInitialized {return false}
      case .location(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._expireAfterMillis)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 3:
          var v: ImageAsset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .image(v)}
        case 4:
          var v: Knock?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .knock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .knock(v)}
        case 5:
          var v: Asset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .asset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .asset(v)}
        case 6:
          var v: Location?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .location(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._expireAfterMillis {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      switch _storage._content {
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .knock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .asset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ephemeral, rhs: Ephemeral) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expireAfterMillis != rhs_storage._expireAfterMillis {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    3: .standard(proto: "link_preview"),
    4: .same(proto: "mentions"),
    5: .same(proto: "quote"),
    6: .standard(proto: "expects_read_confirmation"),
    7: .standard(proto: "legal_hold_status"),
  ]

  fileprivate class _StorageClass {
    var _content: String? = nil
    var _linkPreview: [LinkPreview] = []
    var _mentions: [Mention] = []
    var _quote: Quote? = nil
    var _expectsReadConfirmation: Bool? = nil
    var _legalHoldStatus: LegalHoldStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
      _linkPreview = source._linkPreview
      _mentions = source._mentions
      _quote = source._quote
      _expectsReadConfirmation = source._expectsReadConfirmation
      _legalHoldStatus = source._legalHoldStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._content == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._linkPreview) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mentions) {return false}
      if let v = _storage._quote, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._content)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._linkPreview)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._mentions)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._quote)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._expectsReadConfirmation)
        case 7: try decoder.decodeSingularEnumField(value: &_storage._legalHoldStatus)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._content {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._linkPreview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkPreview, fieldNumber: 3)
      }
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 4)
      }
      if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._expectsReadConfirmation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._legalHoldStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Text, rhs: Text) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        if _storage._linkPreview != rhs_storage._linkPreview {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._expectsReadConfirmation != rhs_storage._expectsReadConfirmation {return false}
        if _storage._legalHoldStatus != rhs_storage._legalHoldStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Knock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Knock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hot_knock"),
    2: .standard(proto: "expects_read_confirmation"),
    3: .standard(proto: "legal_hold_status"),
  ]

  public var isInitialized: Bool {
    if self._hotKnock == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._hotKnock)
      case 2: try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation)
      case 3: try decoder.decodeSingularEnumField(value: &self._legalHoldStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hotKnock {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Knock, rhs: Knock) -> Bool {
    if lhs._hotKnock != rhs._hotKnock {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinkPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "url_offset"),
    3: .same(proto: "article"),
    5: .standard(proto: "permanent_url"),
    6: .same(proto: "title"),
    7: .same(proto: "summary"),
    8: .same(proto: "image"),
    9: .same(proto: "tweet"),
  ]

  fileprivate class _StorageClass {
    var _url: String? = nil
    var _urlOffset: Int32? = nil
    var _preview: LinkPreview.OneOf_Preview?
    var _permanentURL: String? = nil
    var _title: String? = nil
    var _summary: String? = nil
    var _image: Asset? = nil
    var _metaData: LinkPreview.OneOf_MetaData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _urlOffset = source._urlOffset
      _preview = source._preview
      _permanentURL = source._permanentURL
      _title = source._title
      _summary = source._summary
      _image = source._image
      _metaData = source._metaData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._url == nil {return false}
      if _storage._urlOffset == nil {return false}
      if case .article(let v)? = _storage._preview, !v.isInitialized {return false}
      if let v = _storage._image, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._url)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._urlOffset)
        case 3:
          var v: Article?
          if let current = _storage._preview {
            try decoder.handleConflictingOneOf()
            if case .article(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preview = .article(v)}
        case 5: try decoder.decodeSingularStringField(value: &_storage._permanentURL)
        case 6: try decoder.decodeSingularStringField(value: &_storage._title)
        case 7: try decoder.decodeSingularStringField(value: &_storage._summary)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._image)
        case 9:
          var v: Tweet?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .tweet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .tweet(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._urlOffset {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if case .article(let v)? = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._permanentURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._summary {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if case .tweet(let v)? = _storage._metaData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinkPreview, rhs: LinkPreview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._urlOffset != rhs_storage._urlOffset {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._permanentURL != rhs_storage._permanentURL {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tweet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Tweet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._author)
      case 2: try decoder.decodeSingularStringField(value: &self._username)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tweet, rhs: Tweet) -> Bool {
    if lhs._author != rhs._author {return false}
    if lhs._username != rhs._username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Article"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "permanent_url"),
    2: .same(proto: "title"),
    3: .same(proto: "summary"),
    4: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _permanentURL: String? = nil
    var _title: String? = nil
    var _summary: String? = nil
    var _image: Asset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _permanentURL = source._permanentURL
      _title = source._title
      _summary = source._summary
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._permanentURL == nil {return false}
      if let v = _storage._image, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._permanentURL)
        case 2: try decoder.decodeSingularStringField(value: &_storage._title)
        case 3: try decoder.decodeSingularStringField(value: &_storage._summary)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._image)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._permanentURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._summary {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Article, rhs: Article) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._permanentURL != rhs_storage._permanentURL {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Mention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .standard(proto: "user_id"),
  ]

  public var isInitialized: Bool {
    if self._start == nil {return false}
    if self._length == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._start)
      case 2: try decoder.decodeSingularInt32Field(value: &self._length)
      case 3:
        if self.mentionType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.mentionType = .userID(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._length {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if case .userID(let v)? = self.mentionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mention, rhs: Mention) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs.mentionType != rhs.mentionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LastRead"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "last_read_timestamp"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._lastReadTimestamp == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularInt64Field(value: &self._lastReadTimestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._lastReadTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastRead, rhs: LastRead) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._lastReadTimestamp != rhs._lastReadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cleared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Cleared"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "cleared_timestamp"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._clearedTimestamp == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularInt64Field(value: &self._clearedTimestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._clearedTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cleared, rhs: Cleared) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._clearedTimestamp != rhs._clearedTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageHide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageHide"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._messageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageHide, rhs: MessageHide) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageDelete, rhs: MessageDelete) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageEdit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replacing_message_id"),
    2: .same(proto: "text"),
  ]

  fileprivate class _StorageClass {
    var _replacingMessageID: String? = nil
    var _content: MessageEdit.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replacingMessageID = source._replacingMessageID
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._replacingMessageID == nil {return false}
      if case .text(let v)? = _storage._content, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._replacingMessageID)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replacingMessageID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if case .text(let v)? = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEdit, rhs: MessageEdit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replacingMessageID != rhs_storage._replacingMessageID {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Quote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quoted_message_id"),
    2: .standard(proto: "quoted_message_sha256"),
  ]

  public var isInitialized: Bool {
    if self._quotedMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._quotedMessageID)
      case 2: try decoder.decodeSingularBytesField(value: &self._quotedMessageSha256)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._quotedMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._quotedMessageSha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Quote, rhs: Quote) -> Bool {
    if lhs._quotedMessageID != rhs._quotedMessageID {return false}
    if lhs._quotedMessageSha256 != rhs._quotedMessageSha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Confirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    1: .standard(proto: "first_message_id"),
    3: .standard(proto: "more_message_ids"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._firstMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._firstMessageID)
      case 2: try decoder.decodeSingularEnumField(value: &self._type)
      case 3: try decoder.decodeRepeatedStringField(value: &self.moreMessageIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._firstMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if !self.moreMessageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.moreMessageIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Confirmation, rhs: Confirmation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._firstMessageID != rhs._firstMessageID {return false}
    if lhs.moreMessageIds != rhs.moreMessageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERED"),
    1: .same(proto: "READ"),
  ]
}

extension Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "name"),
    4: .same(proto: "zoom"),
    5: .standard(proto: "expects_read_confirmation"),
    6: .standard(proto: "legal_hold_status"),
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self._longitude)
      case 2: try decoder.decodeSingularFloatField(value: &self._latitude)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularInt32Field(value: &self._zoom)
      case 5: try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation)
      case 6: try decoder.decodeSingularEnumField(value: &self._legalHoldStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._zoom {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Location, rhs: Location) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._name != rhs._name {return false}
    if lhs._zoom != rhs._zoom {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .standard(proto: "original_width"),
    5: .standard(proto: "original_height"),
    6: .standard(proto: "mime_type"),
    7: .same(proto: "size"),
    8: .standard(proto: "otr_key"),
    9: .standard(proto: "mac_key"),
    10: .same(proto: "mac"),
    11: .same(proto: "sha256"),
  ]

  public var isInitialized: Bool {
    if self._tag == nil {return false}
    if self._width == nil {return false}
    if self._height == nil {return false}
    if self._originalWidth == nil {return false}
    if self._originalHeight == nil {return false}
    if self._mimeType == nil {return false}
    if self._size == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._tag)
      case 2: try decoder.decodeSingularInt32Field(value: &self._width)
      case 3: try decoder.decodeSingularInt32Field(value: &self._height)
      case 4: try decoder.decodeSingularInt32Field(value: &self._originalWidth)
      case 5: try decoder.decodeSingularInt32Field(value: &self._originalHeight)
      case 6: try decoder.decodeSingularStringField(value: &self._mimeType)
      case 7: try decoder.decodeSingularInt32Field(value: &self._size)
      case 8: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 9: try decoder.decodeSingularBytesField(value: &self._macKey)
      case 10: try decoder.decodeSingularBytesField(value: &self._mac)
      case 11: try decoder.decodeSingularBytesField(value: &self._sha256)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._originalWidth {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._originalHeight {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._size {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._macKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }
    if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageAsset, rhs: ImageAsset) -> Bool {
    if lhs._tag != rhs._tag {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._originalWidth != rhs._originalWidth {return false}
    if lhs._originalHeight != rhs._originalHeight {return false}
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._size != rhs._size {return false}
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._macKey != rhs._macKey {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Asset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "original"),
    3: .standard(proto: "not_uploaded"),
    4: .same(proto: "uploaded"),
    5: .same(proto: "preview"),
    6: .standard(proto: "expects_read_confirmation"),
    7: .standard(proto: "legal_hold_status"),
  ]

  fileprivate class _StorageClass {
    var _original: Asset.Original? = nil
    var _status: Asset.OneOf_Status?
    var _preview: Asset.Preview? = nil
    var _expectsReadConfirmation: Bool? = nil
    var _legalHoldStatus: LegalHoldStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _original = source._original
      _status = source._status
      _preview = source._preview
      _expectsReadConfirmation = source._expectsReadConfirmation
      _legalHoldStatus = source._legalHoldStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._original, !v.isInitialized {return false}
      if case .uploaded(let v)? = _storage._status, !v.isInitialized {return false}
      if let v = _storage._preview, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._original)
        case 3:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: Asset.NotUploaded?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._status = .notUploaded(v)}
        case 4:
          var v: Asset.RemoteData?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .uploaded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .uploaded(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._preview)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._expectsReadConfirmation)
        case 7: try decoder.decodeSingularEnumField(value: &_storage._legalHoldStatus)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._original {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .notUploaded(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      case .uploaded(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
      if let v = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._expectsReadConfirmation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._legalHoldStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset, rhs: Asset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._original != rhs_storage._original {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._expectsReadConfirmation != rhs_storage._expectsReadConfirmation {return false}
        if _storage._legalHoldStatus != rhs_storage._legalHoldStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.NotUploaded: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANCELLED"),
    1: .same(proto: "FAILED"),
  ]
}

extension Asset.Original: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".Original"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "name"),
    4: .same(proto: "image"),
    5: .same(proto: "video"),
    6: .same(proto: "audio"),
    7: .same(proto: "source"),
    8: .same(proto: "caption"),
  ]

  fileprivate class _StorageClass {
    var _mimeType: String? = nil
    var _size: UInt64? = nil
    var _name: String? = nil
    var _metaData: Asset.Original.OneOf_MetaData?
    var _source: String? = nil
    var _caption: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mimeType = source._mimeType
      _size = source._size
      _name = source._name
      _metaData = source._metaData
      _source = source._source
      _caption = source._caption
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mimeType == nil {return false}
      if _storage._size == nil {return false}
      if case .image(let v)? = _storage._metaData, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._mimeType)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4:
          var v: Asset.ImageMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .image(v)}
        case 5:
          var v: Asset.VideoMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .video(v)}
        case 6:
          var v: Asset.AudioMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .audio(v)}
        case 7: try decoder.decodeSingularStringField(value: &_storage._source)
        case 8: try decoder.decodeSingularStringField(value: &_storage._caption)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mimeType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      switch _storage._metaData {
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .video(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .audio(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
      if let v = _storage._source {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._caption {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.Original, rhs: Asset.Original) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mimeType != rhs_storage._mimeType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._caption != rhs_storage._caption {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".Preview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "remote"),
    4: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _mimeType: String? = nil
    var _size: UInt64? = nil
    var _remote: Asset.RemoteData? = nil
    var _metaData: Asset.Preview.OneOf_MetaData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mimeType = source._mimeType
      _size = source._size
      _remote = source._remote
      _metaData = source._metaData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mimeType == nil {return false}
      if _storage._size == nil {return false}
      if let v = _storage._remote, !v.isInitialized {return false}
      if case .image(let v)? = _storage._metaData, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._mimeType)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._remote)
        case 4:
          var v: Asset.ImageMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .image(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mimeType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._remote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .image(let v)? = _storage._metaData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.Preview, rhs: Asset.Preview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mimeType != rhs_storage._mimeType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._remote != rhs_storage._remote {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.ImageMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".ImageMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "tag"),
  ]

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._width)
      case 2: try decoder.decodeSingularInt32Field(value: &self._height)
      case 3: try decoder.decodeSingularStringField(value: &self._tag)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.ImageMetaData, rhs: Asset.ImageMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.VideoMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".VideoMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .standard(proto: "duration_in_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._width)
      case 2: try decoder.decodeSingularInt32Field(value: &self._height)
      case 3: try decoder.decodeSingularUInt64Field(value: &self._durationInMillis)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.VideoMetaData, rhs: Asset.VideoMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.AudioMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".AudioMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_in_millis"),
    3: .standard(proto: "normalized_loudness"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._durationInMillis)
      case 3: try decoder.decodeSingularBytesField(value: &self._normalizedLoudness)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._normalizedLoudness {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.AudioMetaData, rhs: Asset.AudioMetaData) -> Bool {
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs._normalizedLoudness != rhs._normalizedLoudness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.RemoteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".RemoteData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .standard(proto: "asset_id"),
    5: .standard(proto: "asset_token"),
    6: .same(proto: "encryption"),
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    if self._sha256 == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 2: try decoder.decodeSingularBytesField(value: &self._sha256)
      case 3: try decoder.decodeSingularStringField(value: &self._assetID)
      case 5: try decoder.decodeSingularStringField(value: &self._assetToken)
      case 6: try decoder.decodeSingularEnumField(value: &self._encryption)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._assetID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._assetToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.RemoteData, rhs: Asset.RemoteData) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._assetToken != rhs._assetToken {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "External"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .same(proto: "encryption"),
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 2: try decoder.decodeSingularBytesField(value: &self._sha256)
      case 3: try decoder.decodeSingularEnumField(value: &self._encryption)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External, rhs: External) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Reaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._emoji)
      case 2: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Calling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Calling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public var isInitialized: Bool {
    if self._content == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._content)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Calling, rhs: Calling) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
