//
// Wire
// Copyright (C) 2024 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: otr.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Wire
// Copyright (C) 2024 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proteus_Priority: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 0 is reserved for errors
  case lowPriority // = 1
  case highPriority // = 2

  public init() {
    self = .lowPriority
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .lowPriority
    case 2: self = .highPriority
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .lowPriority: return 1
    case .highPriority: return 2
    }
  }

}

#if swift(>=4.2)

extension Proteus_Priority: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Proteus_UserId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: Data? = nil
}

public struct Proteus_QualifiedUserId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {self._domain = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _domain: String? = nil
}

public struct Proteus_ClientId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var client: UInt64 {
    get {return _client ?? 0}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  public var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  public mutating func clearClient() {self._client = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _client: UInt64? = nil
}

public struct Proteus_ClientEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var client: Proteus_ClientId {
    get {return _client ?? Proteus_ClientId()}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  public var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  public mutating func clearClient() {self._client = nil}

  public var text: Data {
    get {return _text ?? Data()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _client: Proteus_ClientId? = nil
  fileprivate var _text: Data? = nil
}

public struct Proteus_UserEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: Proteus_UserId {
    get {return _user ?? Proteus_UserId()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var clients: [Proteus_ClientEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: Proteus_UserId? = nil
}

public struct Proteus_QualifiedUserEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {self._domain = nil}

  public var entries: [Proteus_UserEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _domain: String? = nil
}

/// deprecated, use QualifiedNewOtrMessage
public struct Proteus_NewOtrMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Proteus_ClientId {
    get {return _sender ?? Proteus_ClientId()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var recipients: [Proteus_UserEntry] = []

  public var nativePush: Bool {
    get {return _nativePush ?? true}
    set {_nativePush = newValue}
  }
  /// Returns true if `nativePush` has been explicitly set.
  public var hasNativePush: Bool {return self._nativePush != nil}
  /// Clears the value of `nativePush`. Subsequent reads from it will return its default value.
  public mutating func clearNativePush() {self._nativePush = nil}

  public var blob: Data {
    get {return _blob ?? Data()}
    set {_blob = newValue}
  }
  /// Returns true if `blob` has been explicitly set.
  public var hasBlob: Bool {return self._blob != nil}
  /// Clears the value of `blob`. Subsequent reads from it will return its default value.
  public mutating func clearBlob() {self._blob = nil}

  public var nativePriority: Proteus_Priority {
    get {return _nativePriority ?? .lowPriority}
    set {_nativePriority = newValue}
  }
  /// Returns true if `nativePriority` has been explicitly set.
  public var hasNativePriority: Bool {return self._nativePriority != nil}
  /// Clears the value of `nativePriority`. Subsequent reads from it will return its default value.
  public mutating func clearNativePriority() {self._nativePriority = nil}

  public var transient: Bool {
    get {return _transient ?? false}
    set {_transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  public var hasTransient: Bool {return self._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  public mutating func clearTransient() {self._transient = nil}

  public var reportMissing: [Proteus_UserId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Proteus_ClientId? = nil
  fileprivate var _nativePush: Bool? = nil
  fileprivate var _blob: Data? = nil
  fileprivate var _nativePriority: Proteus_Priority? = nil
  fileprivate var _transient: Bool? = nil
}

public struct Proteus_QualifiedNewOtrMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Proteus_ClientId {
    get {return _sender ?? Proteus_ClientId()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var recipients: [Proteus_QualifiedUserEntry] = []

  public var nativePush: Bool {
    get {return _nativePush ?? true}
    set {_nativePush = newValue}
  }
  /// Returns true if `nativePush` has been explicitly set.
  public var hasNativePush: Bool {return self._nativePush != nil}
  /// Clears the value of `nativePush`. Subsequent reads from it will return its default value.
  public mutating func clearNativePush() {self._nativePush = nil}

  public var blob: Data {
    get {return _blob ?? Data()}
    set {_blob = newValue}
  }
  /// Returns true if `blob` has been explicitly set.
  public var hasBlob: Bool {return self._blob != nil}
  /// Clears the value of `blob`. Subsequent reads from it will return its default value.
  public mutating func clearBlob() {self._blob = nil}

  public var nativePriority: Proteus_Priority {
    get {return _nativePriority ?? .lowPriority}
    set {_nativePriority = newValue}
  }
  /// Returns true if `nativePriority` has been explicitly set.
  public var hasNativePriority: Bool {return self._nativePriority != nil}
  /// Clears the value of `nativePriority`. Subsequent reads from it will return its default value.
  public mutating func clearNativePriority() {self._nativePriority = nil}

  public var transient: Bool {
    get {return _transient ?? false}
    set {_transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  public var hasTransient: Bool {return self._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  public mutating func clearTransient() {self._transient = nil}

  /// For more details please refer to backend swagger at
  /// https://staging-nginz-https.zinfra.io/api/swagger-ui/
  public var clientMismatchStrategy: Proteus_QualifiedNewOtrMessage.OneOf_ClientMismatchStrategy? = nil

  public var reportAll: Proteus_ClientMismatchStrategy.ReportAll {
    get {
      if case .reportAll(let v)? = clientMismatchStrategy {return v}
      return Proteus_ClientMismatchStrategy.ReportAll()
    }
    set {clientMismatchStrategy = .reportAll(newValue)}
  }

  public var ignoreAll: Proteus_ClientMismatchStrategy.IgnoreAll {
    get {
      if case .ignoreAll(let v)? = clientMismatchStrategy {return v}
      return Proteus_ClientMismatchStrategy.IgnoreAll()
    }
    set {clientMismatchStrategy = .ignoreAll(newValue)}
  }

  public var reportOnly: Proteus_ClientMismatchStrategy.ReportOnly {
    get {
      if case .reportOnly(let v)? = clientMismatchStrategy {return v}
      return Proteus_ClientMismatchStrategy.ReportOnly()
    }
    set {clientMismatchStrategy = .reportOnly(newValue)}
  }

  public var ignoreOnly: Proteus_ClientMismatchStrategy.IgnoreOnly {
    get {
      if case .ignoreOnly(let v)? = clientMismatchStrategy {return v}
      return Proteus_ClientMismatchStrategy.IgnoreOnly()
    }
    set {clientMismatchStrategy = .ignoreOnly(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// For more details please refer to backend swagger at
  /// https://staging-nginz-https.zinfra.io/api/swagger-ui/
  public enum OneOf_ClientMismatchStrategy: Equatable {
    case reportAll(Proteus_ClientMismatchStrategy.ReportAll)
    case ignoreAll(Proteus_ClientMismatchStrategy.IgnoreAll)
    case reportOnly(Proteus_ClientMismatchStrategy.ReportOnly)
    case ignoreOnly(Proteus_ClientMismatchStrategy.IgnoreOnly)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .reportOnly: return {
        guard case .reportOnly(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ignoreOnly: return {
        guard case .ignoreOnly(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Proteus_QualifiedNewOtrMessage.OneOf_ClientMismatchStrategy, rhs: Proteus_QualifiedNewOtrMessage.OneOf_ClientMismatchStrategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reportAll, .reportAll): return {
        guard case .reportAll(let l) = lhs, case .reportAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ignoreAll, .ignoreAll): return {
        guard case .ignoreAll(let l) = lhs, case .ignoreAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reportOnly, .reportOnly): return {
        guard case .reportOnly(let l) = lhs, case .reportOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ignoreOnly, .ignoreOnly): return {
        guard case .ignoreOnly(let l) = lhs, case .ignoreOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _sender: Proteus_ClientId? = nil
  fileprivate var _nativePush: Bool? = nil
  fileprivate var _blob: Data? = nil
  fileprivate var _nativePriority: Proteus_Priority? = nil
  fileprivate var _transient: Bool? = nil
}

public struct Proteus_ClientMismatchStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ReportAll {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IgnoreAll {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ReportOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userIds: [Proteus_QualifiedUserId] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IgnoreOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userIds: [Proteus_QualifiedUserId] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Proteus_OtrAssetMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Proteus_ClientId {
    get {return _sender ?? Proteus_ClientId()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var recipients: [Proteus_UserEntry] = []

  public var isInline: Bool {
    get {return _isInline ?? false}
    set {_isInline = newValue}
  }
  /// Returns true if `isInline` has been explicitly set.
  public var hasIsInline: Bool {return self._isInline != nil}
  /// Clears the value of `isInline`. Subsequent reads from it will return its default value.
  public mutating func clearIsInline() {self._isInline = nil}

  public var nativePush: Bool {
    get {return _nativePush ?? true}
    set {_nativePush = newValue}
  }
  /// Returns true if `nativePush` has been explicitly set.
  public var hasNativePush: Bool {return self._nativePush != nil}
  /// Clears the value of `nativePush`. Subsequent reads from it will return its default value.
  public mutating func clearNativePush() {self._nativePush = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Proteus_ClientId? = nil
  fileprivate var _isInline: Bool? = nil
  fileprivate var _nativePush: Bool? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proteus_Priority: @unchecked Sendable {}
extension Proteus_UserId: @unchecked Sendable {}
extension Proteus_QualifiedUserId: @unchecked Sendable {}
extension Proteus_ClientId: @unchecked Sendable {}
extension Proteus_ClientEntry: @unchecked Sendable {}
extension Proteus_UserEntry: @unchecked Sendable {}
extension Proteus_QualifiedUserEntry: @unchecked Sendable {}
extension Proteus_NewOtrMessage: @unchecked Sendable {}
extension Proteus_QualifiedNewOtrMessage: @unchecked Sendable {}
extension Proteus_QualifiedNewOtrMessage.OneOf_ClientMismatchStrategy: @unchecked Sendable {}
extension Proteus_ClientMismatchStrategy: @unchecked Sendable {}
extension Proteus_ClientMismatchStrategy.ReportAll: @unchecked Sendable {}
extension Proteus_ClientMismatchStrategy.IgnoreAll: @unchecked Sendable {}
extension Proteus_ClientMismatchStrategy.ReportOnly: @unchecked Sendable {}
extension Proteus_ClientMismatchStrategy.IgnoreOnly: @unchecked Sendable {}
extension Proteus_OtrAssetMeta: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proteus"

extension Proteus_Priority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LOW_PRIORITY"),
    2: .same(proto: "HIGH_PRIORITY"),
  ]
}

extension Proteus_UserId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_UserId, rhs: Proteus_UserId) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_QualifiedUserId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualifiedUserId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "domain"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._domain == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_QualifiedUserId, rhs: Proteus_QualifiedUserId) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._domain != rhs._domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
  ]

  public var isInitialized: Bool {
    if self._client == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._client) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._client {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientId, rhs: Proteus_ClientId) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "text"),
  ]

  public var isInitialized: Bool {
    if self._client == nil {return false}
    if self._text == nil {return false}
    if let v = self._client, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._client) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._client {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientEntry, rhs: Proteus_ClientEntry) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_UserEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "clients"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.clients) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.clients) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.clients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clients, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_UserEntry, rhs: Proteus_UserEntry) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.clients != rhs.clients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_QualifiedUserEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualifiedUserEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "entries"),
  ]

  public var isInitialized: Bool {
    if self._domain == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_QualifiedUserEntry, rhs: Proteus_QualifiedUserEntry) -> Bool {
    if lhs._domain != rhs._domain {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_NewOtrMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewOtrMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipients"),
    3: .standard(proto: "native_push"),
    4: .same(proto: "blob"),
    5: .standard(proto: "native_priority"),
    6: .same(proto: "transient"),
    7: .standard(proto: "report_missing"),
  ]

  public var isInitialized: Bool {
    if self._sender == nil {return false}
    if let v = self._sender, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.recipients) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.reportMissing) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recipients) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._nativePush) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._blob) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._nativePriority) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._transient) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.reportMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.recipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipients, fieldNumber: 2)
    }
    try { if let v = self._nativePush {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._blob {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._nativePriority {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._transient {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    if !self.reportMissing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reportMissing, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_NewOtrMessage, rhs: Proteus_NewOtrMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.recipients != rhs.recipients {return false}
    if lhs._nativePush != rhs._nativePush {return false}
    if lhs._blob != rhs._blob {return false}
    if lhs._nativePriority != rhs._nativePriority {return false}
    if lhs._transient != rhs._transient {return false}
    if lhs.reportMissing != rhs.reportMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_QualifiedNewOtrMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualifiedNewOtrMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipients"),
    3: .standard(proto: "native_push"),
    4: .same(proto: "blob"),
    5: .standard(proto: "native_priority"),
    6: .same(proto: "transient"),
    7: .standard(proto: "report_all"),
    8: .standard(proto: "ignore_all"),
    9: .standard(proto: "report_only"),
    10: .standard(proto: "ignore_only"),
  ]

  public var isInitialized: Bool {
    if self._sender == nil {return false}
    if let v = self._sender, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.recipients) {return false}
    if let v = self.clientMismatchStrategy, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recipients) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._nativePush) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._blob) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._nativePriority) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._transient) }()
      case 7: try {
        var v: Proteus_ClientMismatchStrategy.ReportAll?
        var hadOneofValue = false
        if let current = self.clientMismatchStrategy {
          hadOneofValue = true
          if case .reportAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.clientMismatchStrategy = .reportAll(v)
        }
      }()
      case 8: try {
        var v: Proteus_ClientMismatchStrategy.IgnoreAll?
        var hadOneofValue = false
        if let current = self.clientMismatchStrategy {
          hadOneofValue = true
          if case .ignoreAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.clientMismatchStrategy = .ignoreAll(v)
        }
      }()
      case 9: try {
        var v: Proteus_ClientMismatchStrategy.ReportOnly?
        var hadOneofValue = false
        if let current = self.clientMismatchStrategy {
          hadOneofValue = true
          if case .reportOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.clientMismatchStrategy = .reportOnly(v)
        }
      }()
      case 10: try {
        var v: Proteus_ClientMismatchStrategy.IgnoreOnly?
        var hadOneofValue = false
        if let current = self.clientMismatchStrategy {
          hadOneofValue = true
          if case .ignoreOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.clientMismatchStrategy = .ignoreOnly(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.recipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipients, fieldNumber: 2)
    }
    try { if let v = self._nativePush {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._blob {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._nativePriority {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._transient {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    switch self.clientMismatchStrategy {
    case .reportAll?: try {
      guard case .reportAll(let v)? = self.clientMismatchStrategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .ignoreAll?: try {
      guard case .ignoreAll(let v)? = self.clientMismatchStrategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .reportOnly?: try {
      guard case .reportOnly(let v)? = self.clientMismatchStrategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .ignoreOnly?: try {
      guard case .ignoreOnly(let v)? = self.clientMismatchStrategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_QualifiedNewOtrMessage, rhs: Proteus_QualifiedNewOtrMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.recipients != rhs.recipients {return false}
    if lhs._nativePush != rhs._nativePush {return false}
    if lhs._blob != rhs._blob {return false}
    if lhs._nativePriority != rhs._nativePriority {return false}
    if lhs._transient != rhs._transient {return false}
    if lhs.clientMismatchStrategy != rhs.clientMismatchStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientMismatchStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMismatchStrategy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientMismatchStrategy, rhs: Proteus_ClientMismatchStrategy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientMismatchStrategy.ReportAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proteus_ClientMismatchStrategy.protoMessageName + ".ReportAll"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientMismatchStrategy.ReportAll, rhs: Proteus_ClientMismatchStrategy.ReportAll) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientMismatchStrategy.IgnoreAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proteus_ClientMismatchStrategy.protoMessageName + ".IgnoreAll"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientMismatchStrategy.IgnoreAll, rhs: Proteus_ClientMismatchStrategy.IgnoreAll) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientMismatchStrategy.ReportOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proteus_ClientMismatchStrategy.protoMessageName + ".ReportOnly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.userIds) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientMismatchStrategy.ReportOnly, rhs: Proteus_ClientMismatchStrategy.ReportOnly) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_ClientMismatchStrategy.IgnoreOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proteus_ClientMismatchStrategy.protoMessageName + ".IgnoreOnly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.userIds) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_ClientMismatchStrategy.IgnoreOnly, rhs: Proteus_ClientMismatchStrategy.IgnoreOnly) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proteus_OtrAssetMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtrAssetMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipients"),
    3: .same(proto: "isInline"),
    4: .standard(proto: "native_push"),
  ]

  public var isInitialized: Bool {
    if self._sender == nil {return false}
    if let v = self._sender, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.recipients) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recipients) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isInline) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._nativePush) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.recipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipients, fieldNumber: 2)
    }
    try { if let v = self._isInline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nativePush {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proteus_OtrAssetMeta, rhs: Proteus_OtrAssetMeta) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.recipients != rhs.recipients {return false}
    if lhs._isInline != rhs._isInline {return false}
    if lhs._nativePush != rhs._nativePush {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
