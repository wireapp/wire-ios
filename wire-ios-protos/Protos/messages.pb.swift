//
// Wire
// Copyright (C) 2022 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Wire
// Copyright (C) 2021 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ClientAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case resetSession // = 0

  public init() {
    self = .resetSession
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resetSession
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .resetSession: return 0
    }
  }

}

#if swift(>=4.2)

extension ClientAction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum EncryptionAlgorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case aesCbc // = 0
  case aesGcm // = 1

  public init() {
    self = .aesCbc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aesCbc
    case 1: self = .aesGcm
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .aesCbc: return 0
    case .aesGcm: return 1
    }
  }

}

#if swift(>=4.2)

extension EncryptionAlgorithm: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum LegalHoldStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case disabled // = 1
  case enabled // = 2

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .disabled
    case 2: self = .enabled
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .disabled: return 1
    case .enabled: return 2
    }
  }

}

#if swift(>=4.2)

extension LegalHoldStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct GenericMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// client generated random id, preferably UUID
  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var content: GenericMessage.OneOf_Content?

  public var text: Text {
    get {
      if case .text(let v)? = content {return v}
      return Text()
    }
    set {content = .text(newValue)}
  }

  /// deprecated in favour of Asset
  public var image: ImageAsset {
    get {
      if case .image(let v)? = content {return v}
      return ImageAsset()
    }
    set {content = .image(newValue)}
  }

  public var knock: Knock {
    get {
      if case .knock(let v)? = content {return v}
      return Knock()
    }
    set {content = .knock(newValue)}
  }

  public var lastRead: LastRead {
    get {
      if case .lastRead(let v)? = content {return v}
      return LastRead()
    }
    set {content = .lastRead(newValue)}
  }

  public var cleared: Cleared {
    get {
      if case .cleared(let v)? = content {return v}
      return Cleared()
    }
    set {content = .cleared(newValue)}
  }

  public var external: External {
    get {
      if case .external(let v)? = content {return v}
      return External()
    }
    set {content = .external(newValue)}
  }

  public var clientAction: ClientAction {
    get {
      if case .clientAction(let v)? = content {return v}
      return .resetSession
    }
    set {content = .clientAction(newValue)}
  }

  public var calling: Calling {
    get {
      if case .calling(let v)? = content {return v}
      return Calling()
    }
    set {content = .calling(newValue)}
  }

  public var asset: Asset {
    get {
      if case .asset(let v)? = content {return v}
      return Asset()
    }
    set {content = .asset(newValue)}
  }

  public var hidden: MessageHide {
    get {
      if case .hidden(let v)? = content {return v}
      return MessageHide()
    }
    set {content = .hidden(newValue)}
  }

  public var location: Location {
    get {
      if case .location(let v)? = content {return v}
      return Location()
    }
    set {content = .location(newValue)}
  }

  public var deleted: MessageDelete {
    get {
      if case .deleted(let v)? = content {return v}
      return MessageDelete()
    }
    set {content = .deleted(newValue)}
  }

  public var edited: MessageEdit {
    get {
      if case .edited(let v)? = content {return v}
      return MessageEdit()
    }
    set {content = .edited(newValue)}
  }

  public var confirmation: Confirmation {
    get {
      if case .confirmation(let v)? = content {return v}
      return Confirmation()
    }
    set {content = .confirmation(newValue)}
  }

  public var reaction: Reaction {
    get {
      if case .reaction(let v)? = content {return v}
      return Reaction()
    }
    set {content = .reaction(newValue)}
  }

  public var ephemeral: Ephemeral {
    get {
      if case .ephemeral(let v)? = content {return v}
      return Ephemeral()
    }
    set {content = .ephemeral(newValue)}
  }

  public var availability: Availability {
    get {
      if case .availability(let v)? = content {return v}
      return Availability()
    }
    set {content = .availability(newValue)}
  }

  public var composite: Composite {
    get {
      if case .composite(let v)? = content {return v}
      return Composite()
    }
    set {content = .composite(newValue)}
  }

  public var buttonAction: ButtonAction {
    get {
      if case .buttonAction(let v)? = content {return v}
      return ButtonAction()
    }
    set {content = .buttonAction(newValue)}
  }

  public var buttonActionConfirmation: ButtonActionConfirmation {
    get {
      if case .buttonActionConfirmation(let v)? = content {return v}
      return ButtonActionConfirmation()
    }
    set {content = .buttonActionConfirmation(newValue)}
  }

  /// client-side synchronization across devices of the same user
  public var dataTransfer: DataTransfer {
    get {
      if case .dataTransfer(let v)? = content {return v}
      return DataTransfer()
    }
    set {content = .dataTransfer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case text(Text)
    /// deprecated in favour of Asset
    case image(ImageAsset)
    case knock(Knock)
    case lastRead(LastRead)
    case cleared(Cleared)
    case external(External)
    case clientAction(ClientAction)
    case calling(Calling)
    case asset(Asset)
    case hidden(MessageHide)
    case location(Location)
    case deleted(MessageDelete)
    case edited(MessageEdit)
    case confirmation(Confirmation)
    case reaction(Reaction)
    case ephemeral(Ephemeral)
    case availability(Availability)
    case composite(Composite)
    case buttonAction(ButtonAction)
    case buttonActionConfirmation(ButtonActionConfirmation)
    /// client-side synchronization across devices of the same user
    case dataTransfer(DataTransfer)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .text: return {
        guard case .text(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .image: return {
        guard case .image(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .knock: return {
        guard case .knock(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .lastRead: return {
        guard case .lastRead(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .cleared: return {
        guard case .cleared(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .external: return {
        guard case .external(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .calling: return {
        guard case .calling(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .asset: return {
        guard case .asset(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hidden: return {
        guard case .hidden(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .location: return {
        guard case .location(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .deleted: return {
        guard case .deleted(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .edited: return {
        guard case .edited(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .confirmation: return {
        guard case .confirmation(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .reaction: return {
        guard case .reaction(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ephemeral: return {
        guard case .ephemeral(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .availability: return {
        guard case .availability(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .composite: return {
        guard case .composite(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .buttonAction: return {
        guard case .buttonAction(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .buttonActionConfirmation: return {
        guard case .buttonActionConfirmation(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .dataTransfer: return {
        guard case .dataTransfer(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: GenericMessage.OneOf_Content, rhs: GenericMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.knock, .knock): return {
        guard case .knock(let l) = lhs, case .knock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastRead, .lastRead): return {
        guard case .lastRead(let l) = lhs, case .lastRead(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cleared, .cleared): return {
        guard case .cleared(let l) = lhs, case .cleared(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.external, .external): return {
        guard case .external(let l) = lhs, case .external(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientAction, .clientAction): return {
        guard case .clientAction(let l) = lhs, case .clientAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.calling, .calling): return {
        guard case .calling(let l) = lhs, case .calling(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asset, .asset): return {
        guard case .asset(let l) = lhs, case .asset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hidden, .hidden): return {
        guard case .hidden(let l) = lhs, case .hidden(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleted, .deleted): return {
        guard case .deleted(let l) = lhs, case .deleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.edited, .edited): return {
        guard case .edited(let l) = lhs, case .edited(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmation, .confirmation): return {
        guard case .confirmation(let l) = lhs, case .confirmation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reaction, .reaction): return {
        guard case .reaction(let l) = lhs, case .reaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ephemeral, .ephemeral): return {
        guard case .ephemeral(let l) = lhs, case .ephemeral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.availability, .availability): return {
        guard case .availability(let l) = lhs, case .availability(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.composite, .composite): return {
        guard case .composite(let l) = lhs, case .composite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buttonAction, .buttonAction): return {
        guard case .buttonAction(let l) = lhs, case .buttonAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buttonActionConfirmation, .buttonActionConfirmation): return {
        guard case .buttonActionConfirmation(let l) = lhs, case .buttonActionConfirmation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTransfer, .dataTransfer): return {
        guard case .dataTransfer(let l) = lhs, case .dataTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _messageID: String?
}

public struct QualifiedUserId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {self._domain = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String?
  fileprivate var _domain: String?
}

public struct QualifiedConversationId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {self._domain = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String?
  fileprivate var _domain: String?
}

public struct Composite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Composite.Item] = []

  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .unknown}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: Composite.Item.OneOf_Content?

    public var text: Text {
      get {
        if case .text(let v)? = content {return v}
        return Text()
      }
      set {content = .text(newValue)}
    }

    public var button: Button {
      get {
        if case .button(let v)? = content {return v}
        return Button()
      }
      set {content = .button(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case text(Text)
      case button(Button)

      fileprivate var isInitialized: Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch self {
        case .text: return {
          guard case .text(let v) = self else { preconditionFailure() }
          return v.isInitialized
        }()
        case .button: return {
          guard case .button(let v) = self else { preconditionFailure() }
          return v.isInitialized
        }()
        }
      }

    #if !swift(>=4.1)
      public static func ==(lhs: Composite.Item.OneOf_Content, rhs: Composite.Item.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.text, .text): return {
          guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.button, .button): return {
          guard case .button(let l) = lhs, case .button(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _expectsReadConfirmation: Bool?
  fileprivate var _legalHoldStatus: LegalHoldStatus?
}

public struct Button {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String?
  fileprivate var _id: String?
}

public struct ButtonAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var buttonID: String {
    get {return _buttonID ?? String()}
    set {_buttonID = newValue}
  }
  /// Returns true if `buttonID` has been explicitly set.
  public var hasButtonID: Bool {return self._buttonID != nil}
  /// Clears the value of `buttonID`. Subsequent reads from it will return its default value.
  public mutating func clearButtonID() {self._buttonID = nil}

  public var referenceMessageID: String {
    get {return _referenceMessageID ?? String()}
    set {_referenceMessageID = newValue}
  }
  /// Returns true if `referenceMessageID` has been explicitly set.
  public var hasReferenceMessageID: Bool {return self._referenceMessageID != nil}
  /// Clears the value of `referenceMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceMessageID() {self._referenceMessageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _buttonID: String?
  fileprivate var _referenceMessageID: String?
}

public struct ButtonActionConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var referenceMessageID: String {
    get {return _referenceMessageID ?? String()}
    set {_referenceMessageID = newValue}
  }
  /// Returns true if `referenceMessageID` has been explicitly set.
  public var hasReferenceMessageID: Bool {return self._referenceMessageID != nil}
  /// Clears the value of `referenceMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceMessageID() {self._referenceMessageID = nil}

  /// if not present, no button is accepted
  public var buttonID: String {
    get {return _buttonID ?? String()}
    set {_buttonID = newValue}
  }
  /// Returns true if `buttonID` has been explicitly set.
  public var hasButtonID: Bool {return self._buttonID != nil}
  /// Clears the value of `buttonID`. Subsequent reads from it will return its default value.
  public mutating func clearButtonID() {self._buttonID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceMessageID: String?
  fileprivate var _buttonID: String?
}

public struct Availability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Availability.TypeEnum {
    get {return _type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0
    case available // = 1
    case away // = 2
    case busy // = 3

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .available
      case 2: self = .away
      case 3: self = .busy
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .available: return 1
      case .away: return 2
      case .busy: return 3
      }
    }

  }

  public init() {}

  fileprivate var _type: Availability.TypeEnum?
}

#if swift(>=4.2)

extension Availability.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Ephemeral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expireAfterMillis: Int64 {
    get {return _expireAfterMillis ?? 0}
    set {_expireAfterMillis = newValue}
  }
  /// Returns true if `expireAfterMillis` has been explicitly set.
  public var hasExpireAfterMillis: Bool {return self._expireAfterMillis != nil}
  /// Clears the value of `expireAfterMillis`. Subsequent reads from it will return its default value.
  public mutating func clearExpireAfterMillis() {self._expireAfterMillis = nil}

  public var content: Ephemeral.OneOf_Content?

  public var text: Text {
    get {
      if case .text(let v)? = content {return v}
      return Text()
    }
    set {content = .text(newValue)}
  }

  /// deprecated in favour of Asset
  public var image: ImageAsset {
    get {
      if case .image(let v)? = content {return v}
      return ImageAsset()
    }
    set {content = .image(newValue)}
  }

  public var knock: Knock {
    get {
      if case .knock(let v)? = content {return v}
      return Knock()
    }
    set {content = .knock(newValue)}
  }

  public var asset: Asset {
    get {
      if case .asset(let v)? = content {return v}
      return Asset()
    }
    set {content = .asset(newValue)}
  }

  public var location: Location {
    get {
      if case .location(let v)? = content {return v}
      return Location()
    }
    set {content = .location(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case text(Text)
    /// deprecated in favour of Asset
    case image(ImageAsset)
    case knock(Knock)
    case asset(Asset)
    case location(Location)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .text: return {
        guard case .text(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .image: return {
        guard case .image(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .knock: return {
        guard case .knock(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .asset: return {
        guard case .asset(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .location: return {
        guard case .location(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Ephemeral.OneOf_Content, rhs: Ephemeral.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.knock, .knock): return {
        guard case .knock(let l) = lhs, case .knock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asset, .asset): return {
        guard case .asset(let l) = lhs, case .asset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _expireAfterMillis: Int64?
}

public struct Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String {
    get {return _content ?? String()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  /// reserved 2; // reserved keyword is not available in older protoc versions
  public var linkPreview: [LinkPreview] = []

  public var mentions: [Mention] = []

  /// if this Text is part of a MessageEdit, this field is ignored
  public var quote: Quote {
    get {return _quote ?? Quote()}
    set {_quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  public var hasQuote: Bool {return self._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  public mutating func clearQuote() {self._quote = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .unknown}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: String?
  fileprivate var _quote: Quote?
  fileprivate var _expectsReadConfirmation: Bool?
  fileprivate var _legalHoldStatus: LegalHoldStatus?
}

public struct Knock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hotKnock: Bool {
    get {return _hotKnock ?? false}
    set {_hotKnock = newValue}
  }
  /// Returns true if `hotKnock` has been explicitly set.
  public var hasHotKnock: Bool {return self._hotKnock != nil}
  /// Clears the value of `hotKnock`. Subsequent reads from it will return its default value.
  public mutating func clearHotKnock() {self._hotKnock = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .unknown}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hotKnock: Bool?
  fileprivate var _expectsReadConfirmation: Bool?
  fileprivate var _legalHoldStatus: LegalHoldStatus?
}

public struct LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  /// url offset from beginning of text message
  public var urlOffset: Int32 {
    get {return _urlOffset ?? 0}
    set {_urlOffset = newValue}
  }
  /// Returns true if `urlOffset` has been explicitly set.
  public var hasURLOffset: Bool {return self._urlOffset != nil}
  /// Clears the value of `urlOffset`. Subsequent reads from it will return its default value.
  public mutating func clearURLOffset() {self._urlOffset = nil}

  public var preview: LinkPreview.OneOf_Preview?

  /// deprecated - use meta_data
  public var article: Article {
    get {
      if case .article(let v)? = preview {return v}
      return Article()
    }
    set {preview = .article(newValue)}
  }

  public var permanentURL: String {
    get {return _permanentURL ?? String()}
    set {_permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  public var hasPermanentURL: Bool {return self._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  public mutating func clearPermanentURL() {self._permanentURL = nil}

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var summary: String {
    get {return _summary ?? String()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var image: Asset {
    get {return _image ?? Asset()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var metaData: LinkPreview.OneOf_MetaData?

  public var tweet: Tweet {
    get {
      if case .tweet(let v)? = metaData {return v}
      return Tweet()
    }
    set {metaData = .tweet(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Preview: Equatable {
    /// deprecated - use meta_data
    case article(Article)

    fileprivate var isInitialized: Bool {
      guard case .article(let v) = self else {return true}
      return v.isInitialized
    }

  #if !swift(>=4.1)
    public static func ==(lhs: LinkPreview.OneOf_Preview, rhs: LinkPreview.OneOf_Preview) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.article, .article): return {
        guard case .article(let l) = lhs, case .article(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum OneOf_MetaData: Equatable {
    case tweet(Tweet)

  #if !swift(>=4.1)
    public static func ==(lhs: LinkPreview.OneOf_MetaData, rhs: LinkPreview.OneOf_MetaData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tweet, .tweet): return {
        guard case .tweet(let l) = lhs, case .tweet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _url: String?
  fileprivate var _urlOffset: Int32?
  fileprivate var _permanentURL: String?
  fileprivate var _title: String?
  fileprivate var _summary: String?
  fileprivate var _image: Asset?
}

public struct Tweet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _author: String?
  fileprivate var _username: String?
}

/// deprecated - use the additional fields in LinkPreview
public struct Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var permanentURL: String {
    get {return _permanentURL ?? String()}
    set {_permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  public var hasPermanentURL: Bool {return self._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  public mutating func clearPermanentURL() {self._permanentURL = nil}

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var summary: String {
    get {return _summary ?? String()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var image: Asset {
    get {return _image ?? Asset()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _permanentURL: String?
  fileprivate var _title: String?
  fileprivate var _summary: String?
  fileprivate var _image: Asset?
}

public struct Mention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// offset from beginning of the message counting in utf16 characters
  public var start: Int32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var length: Int32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  public var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  public mutating func clearLength() {self._length = nil}

  public var mentionType: Mention.OneOf_MentionType?

  /// deprecated. Should be set such that old clients always fail when looking
  /// up the user. Ideally, this should not be a problem, as a non-federation
  /// aware user should never be part of a federated conversation.
  public var userID: String {
    get {
      if case .userID(let v)? = mentionType {return v}
      return String()
    }
    set {mentionType = .userID(newValue)}
  }

  /// only optional to maintain backwards compatibility.
  public var qualifiedUserID: QualifiedUserId {
    get {return _qualifiedUserID ?? QualifiedUserId()}
    set {_qualifiedUserID = newValue}
  }
  /// Returns true if `qualifiedUserID` has been explicitly set.
  public var hasQualifiedUserID: Bool {return self._qualifiedUserID != nil}
  /// Clears the value of `qualifiedUserID`. Subsequent reads from it will return its default value.
  public mutating func clearQualifiedUserID() {self._qualifiedUserID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MentionType: Equatable {
    /// deprecated. Should be set such that old clients always fail when looking
    /// up the user. Ideally, this should not be a problem, as a non-federation
    /// aware user should never be part of a federated conversation.
    case userID(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Mention.OneOf_MentionType, rhs: Mention.OneOf_MentionType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userID, .userID): return {
        guard case .userID(let l) = lhs, case .userID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _start: Int32?
  fileprivate var _length: Int32?
  fileprivate var _qualifiedUserID: QualifiedUserId?
}

public struct LastRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deprecated. Should be set such that old clients always fail when looking up
  /// the conversation.
  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var lastReadTimestamp: Int64 {
    get {return _lastReadTimestamp ?? 0}
    set {_lastReadTimestamp = newValue}
  }
  /// Returns true if `lastReadTimestamp` has been explicitly set.
  public var hasLastReadTimestamp: Bool {return self._lastReadTimestamp != nil}
  /// Clears the value of `lastReadTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearLastReadTimestamp() {self._lastReadTimestamp = nil}

  /// only optional to maintain backwards compatibility
  public var qualifiedConversationID: QualifiedConversationId {
    get {return _qualifiedConversationID ?? QualifiedConversationId()}
    set {_qualifiedConversationID = newValue}
  }
  /// Returns true if `qualifiedConversationID` has been explicitly set.
  public var hasQualifiedConversationID: Bool {return self._qualifiedConversationID != nil}
  /// Clears the value of `qualifiedConversationID`. Subsequent reads from it will return its default value.
  public mutating func clearQualifiedConversationID() {self._qualifiedConversationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String?
  fileprivate var _lastReadTimestamp: Int64?
  fileprivate var _qualifiedConversationID: QualifiedConversationId?
}

public struct Cleared {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deprecated. Should be set such that old clients always fail when looking up
  /// the conversation.
  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var clearedTimestamp: Int64 {
    get {return _clearedTimestamp ?? 0}
    set {_clearedTimestamp = newValue}
  }
  /// Returns true if `clearedTimestamp` has been explicitly set.
  public var hasClearedTimestamp: Bool {return self._clearedTimestamp != nil}
  /// Clears the value of `clearedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearClearedTimestamp() {self._clearedTimestamp = nil}

  /// only optional to maintain backwards compatibility
  public var qualifiedConversationID: QualifiedConversationId {
    get {return _qualifiedConversationID ?? QualifiedConversationId()}
    set {_qualifiedConversationID = newValue}
  }
  /// Returns true if `qualifiedConversationID` has been explicitly set.
  public var hasQualifiedConversationID: Bool {return self._qualifiedConversationID != nil}
  /// Clears the value of `qualifiedConversationID`. Subsequent reads from it will return its default value.
  public mutating func clearQualifiedConversationID() {self._qualifiedConversationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String?
  fileprivate var _clearedTimestamp: Int64?
  fileprivate var _qualifiedConversationID: QualifiedConversationId?
}

public struct MessageHide {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deprecated. Should be set such that old clients always fail when looking up
  /// the conversation.
  public var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  public var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  public mutating func clearConversationID() {self._conversationID = nil}

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// only optional to maintain backwards compatibility
  public var qualifiedConversationID: QualifiedConversationId {
    get {return _qualifiedConversationID ?? QualifiedConversationId()}
    set {_qualifiedConversationID = newValue}
  }
  /// Returns true if `qualifiedConversationID` has been explicitly set.
  public var hasQualifiedConversationID: Bool {return self._qualifiedConversationID != nil}
  /// Clears the value of `qualifiedConversationID`. Subsequent reads from it will return its default value.
  public mutating func clearQualifiedConversationID() {self._qualifiedConversationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversationID: String?
  fileprivate var _messageID: String?
  fileprivate var _qualifiedConversationID: QualifiedConversationId?
}

public struct MessageDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: String?
}

public struct MessageEdit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replacingMessageID: String {
    get {return _replacingMessageID ?? String()}
    set {_replacingMessageID = newValue}
  }
  /// Returns true if `replacingMessageID` has been explicitly set.
  public var hasReplacingMessageID: Bool {return self._replacingMessageID != nil}
  /// Clears the value of `replacingMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearReplacingMessageID() {self._replacingMessageID = nil}

  public var content: MessageEdit.OneOf_Content?

  public var text: Text {
    get {
      if case .text(let v)? = content {return v}
      return Text()
    }
    set {content = .text(newValue)}
  }

  /// Reply can also be edited, but the edit will only affect the Text part
  public var composite: Composite {
    get {
      if case .composite(let v)? = content {return v}
      return Composite()
    }
    set {content = .composite(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case text(Text)
    /// Reply can also be edited, but the edit will only affect the Text part
    case composite(Composite)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .text: return {
        guard case .text(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .composite: return {
        guard case .composite(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: MessageEdit.OneOf_Content, rhs: MessageEdit.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.composite, .composite): return {
        guard case .composite(let l) = lhs, case .composite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _replacingMessageID: String?
}

public struct Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quotedMessageID: String {
    get {return _quotedMessageID ?? String()}
    set {_quotedMessageID = newValue}
  }
  /// Returns true if `quotedMessageID` has been explicitly set.
  public var hasQuotedMessageID: Bool {return self._quotedMessageID != nil}
  /// Clears the value of `quotedMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearQuotedMessageID() {self._quotedMessageID = nil}

  public var quotedMessageSha256: Data {
    get {return _quotedMessageSha256 ?? Data()}
    set {_quotedMessageSha256 = newValue}
  }
  /// Returns true if `quotedMessageSha256` has been explicitly set.
  public var hasQuotedMessageSha256: Bool {return self._quotedMessageSha256 != nil}
  /// Clears the value of `quotedMessageSha256`. Subsequent reads from it will return its default value.
  public mutating func clearQuotedMessageSha256() {self._quotedMessageSha256 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _quotedMessageID: String?
  fileprivate var _quotedMessageSha256: Data?
}

public struct Confirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Confirmation.TypeEnum {
    get {return _type ?? .delivered}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var firstMessageID: String {
    get {return _firstMessageID ?? String()}
    set {_firstMessageID = newValue}
  }
  /// Returns true if `firstMessageID` has been explicitly set.
  public var hasFirstMessageID: Bool {return self._firstMessageID != nil}
  /// Clears the value of `firstMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearFirstMessageID() {self._firstMessageID = nil}

  public var moreMessageIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case delivered // = 0
    case read // = 1

    public init() {
      self = .delivered
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delivered
      case 1: self = .read
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .delivered: return 0
      case .read: return 1
      }
    }

  }

  public init() {}

  fileprivate var _type: Confirmation.TypeEnum?
  fileprivate var _firstMessageID: String?
}

#if swift(>=4.2)

extension Confirmation.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  public var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  /// location description/name
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// google maps zoom level (check maps api documentation)
  public var zoom: Int32 {
    get {return _zoom ?? 0}
    set {_zoom = newValue}
  }
  /// Returns true if `zoom` has been explicitly set.
  public var hasZoom: Bool {return self._zoom != nil}
  /// Clears the value of `zoom`. Subsequent reads from it will return its default value.
  public mutating func clearZoom() {self._zoom = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _expectsReadConfirmation ?? false}
    set {_expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return self._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {self._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .unknown}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _longitude: Float?
  fileprivate var _latitude: Float?
  fileprivate var _name: String?
  fileprivate var _zoom: Int32?
  fileprivate var _expectsReadConfirmation: Bool?
  fileprivate var _legalHoldStatus: LegalHoldStatus?
}

/// deprecated in favour of Asset.Original.ImageMetaData
public struct ImageAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: String {
    get {return _tag ?? String()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {self._tag = nil}

  public var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  public var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  public mutating func clearWidth() {self._width = nil}

  public var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  public var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  public mutating func clearHeight() {self._height = nil}

  public var originalWidth: Int32 {
    get {return _originalWidth ?? 0}
    set {_originalWidth = newValue}
  }
  /// Returns true if `originalWidth` has been explicitly set.
  public var hasOriginalWidth: Bool {return self._originalWidth != nil}
  /// Clears the value of `originalWidth`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalWidth() {self._originalWidth = nil}

  public var originalHeight: Int32 {
    get {return _originalHeight ?? 0}
    set {_originalHeight = newValue}
  }
  /// Returns true if `originalHeight` has been explicitly set.
  public var hasOriginalHeight: Bool {return self._originalHeight != nil}
  /// Clears the value of `originalHeight`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalHeight() {self._originalHeight = nil}

  public var mimeType: String {
    get {return _mimeType ?? String()}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  public var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  public mutating func clearMimeType() {self._mimeType = nil}

  public var size: Int32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var otrKey: Data {
    get {return _otrKey ?? Data()}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  public var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  public mutating func clearOtrKey() {self._otrKey = nil}

  /// deprecated - use sha256
  public var macKey: Data {
    get {return _macKey ?? Data()}
    set {_macKey = newValue}
  }
  /// Returns true if `macKey` has been explicitly set.
  public var hasMacKey: Bool {return self._macKey != nil}
  /// Clears the value of `macKey`. Subsequent reads from it will return its default value.
  public mutating func clearMacKey() {self._macKey = nil}

  /// deprecated - use sha256
  public var mac: Data {
    get {return _mac ?? Data()}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  public var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  public mutating func clearMac() {self._mac = nil}

  /// sha256 of ciphertext
  public var sha256: Data {
    get {return _sha256 ?? Data()}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  public var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  public mutating func clearSha256() {self._sha256 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tag: String?
  fileprivate var _width: Int32?
  fileprivate var _height: Int32?
  fileprivate var _originalWidth: Int32?
  fileprivate var _originalHeight: Int32?
  fileprivate var _mimeType: String?
  fileprivate var _size: Int32?
  fileprivate var _otrKey: Data?
  fileprivate var _macKey: Data?
  fileprivate var _mac: Data?
  fileprivate var _sha256: Data?
}

public struct Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var original: Asset.Original {
    get {return _storage._original ?? Asset.Original()}
    set {_uniqueStorage()._original = newValue}
  }
  /// Returns true if `original` has been explicitly set.
  public var hasOriginal: Bool {return _storage._original != nil}
  /// Clears the value of `original`. Subsequent reads from it will return its default value.
  public mutating func clearOriginal() {_uniqueStorage()._original = nil}

  /// optional Preview preview = 2;  // deprecated - preview was completely replaced
  public var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var notUploaded: Asset.NotUploaded {
    get {
      if case .notUploaded(let v)? = _storage._status {return v}
      return .cancelled
    }
    set {_uniqueStorage()._status = .notUploaded(newValue)}
  }

  public var uploaded: Asset.RemoteData {
    get {
      if case .uploaded(let v)? = _storage._status {return v}
      return Asset.RemoteData()
    }
    set {_uniqueStorage()._status = .uploaded(newValue)}
  }

  public var preview: Asset.Preview {
    get {return _storage._preview ?? Asset.Preview()}
    set {_uniqueStorage()._preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  public var hasPreview: Bool {return _storage._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  public mutating func clearPreview() {_uniqueStorage()._preview = nil}

  /// whether the sender is expecting to receive a read confirmation
  public var expectsReadConfirmation: Bool {
    get {return _storage._expectsReadConfirmation ?? false}
    set {_uniqueStorage()._expectsReadConfirmation = newValue}
  }
  /// Returns true if `expectsReadConfirmation` has been explicitly set.
  public var hasExpectsReadConfirmation: Bool {return _storage._expectsReadConfirmation != nil}
  /// Clears the value of `expectsReadConfirmation`. Subsequent reads from it will return its default value.
  public mutating func clearExpectsReadConfirmation() {_uniqueStorage()._expectsReadConfirmation = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _storage._legalHoldStatus ?? .unknown}
    set {_uniqueStorage()._legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return _storage._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {_uniqueStorage()._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// optional Preview preview = 2;  // deprecated - preview was completely replaced
  public enum OneOf_Status: Equatable {
    case notUploaded(Asset.NotUploaded)
    case uploaded(Asset.RemoteData)

    fileprivate var isInitialized: Bool {
      guard case .uploaded(let v) = self else {return true}
      return v.isInitialized
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Asset.OneOf_Status, rhs: Asset.OneOf_Status) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.notUploaded, .notUploaded): return {
        guard case .notUploaded(let l) = lhs, case .notUploaded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uploaded, .uploaded): return {
        guard case .uploaded(let l) = lhs, case .uploaded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum NotUploaded: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case cancelled // = 0
    case failed // = 1

    public init() {
      self = .cancelled
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cancelled
      case 1: self = .failed
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .cancelled: return 0
      case .failed: return 1
      }
    }

  }

  public struct Original {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mimeType: String {
      get {return _mimeType ?? String()}
      set {_mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    public var hasMimeType: Bool {return self._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    public mutating func clearMimeType() {self._mimeType = nil}

    public var size: UInt64 {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {self._size = nil}

    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {self._name = nil}

    public var metaData: Asset.Original.OneOf_MetaData?

    public var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = metaData {return v}
        return Asset.ImageMetaData()
      }
      set {metaData = .image(newValue)}
    }

    public var video: Asset.VideoMetaData {
      get {
        if case .video(let v)? = metaData {return v}
        return Asset.VideoMetaData()
      }
      set {metaData = .video(newValue)}
    }

    public var audio: Asset.AudioMetaData {
      get {
        if case .audio(let v)? = metaData {return v}
        return Asset.AudioMetaData()
      }
      set {metaData = .audio(newValue)}
    }

    /// link to source e.g. http://giphy.com/234245
    public var source: String {
      get {return _source ?? String()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    public var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    public mutating func clearSource() {self._source = nil}

    /// caption of the asset, e.g. "dog" for a Giphy "dog" search result
    public var caption: String {
      get {return _caption ?? String()}
      set {_caption = newValue}
    }
    /// Returns true if `caption` has been explicitly set.
    public var hasCaption: Bool {return self._caption != nil}
    /// Clears the value of `caption`. Subsequent reads from it will return its default value.
    public mutating func clearCaption() {self._caption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)
      case video(Asset.VideoMetaData)
      case audio(Asset.AudioMetaData)

      fileprivate var isInitialized: Bool {
        guard case .image(let v) = self else {return true}
        return v.isInitialized
      }

    #if !swift(>=4.1)
      public static func ==(lhs: Asset.Original.OneOf_MetaData, rhs: Asset.Original.OneOf_MetaData) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.image, .image): return {
          guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.video, .video): return {
          guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.audio, .audio): return {
          guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _mimeType: String?
    fileprivate var _size: UInt64?
    fileprivate var _name: String?
    fileprivate var _source: String?
    fileprivate var _caption: String?
  }

  public struct Preview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mimeType: String {
      get {return _mimeType ?? String()}
      set {_mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    public var hasMimeType: Bool {return self._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    public mutating func clearMimeType() {self._mimeType = nil}

    public var size: UInt64 {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {self._size = nil}

    public var remote: Asset.RemoteData {
      get {return _remote ?? Asset.RemoteData()}
      set {_remote = newValue}
    }
    /// Returns true if `remote` has been explicitly set.
    public var hasRemote: Bool {return self._remote != nil}
    /// Clears the value of `remote`. Subsequent reads from it will return its default value.
    public mutating func clearRemote() {self._remote = nil}

    public var metaData: Asset.Preview.OneOf_MetaData?

    public var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = metaData {return v}
        return Asset.ImageMetaData()
      }
      set {metaData = .image(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)

      fileprivate var isInitialized: Bool {
        guard case .image(let v) = self else {return true}
        return v.isInitialized
      }

    #if !swift(>=4.1)
      public static func ==(lhs: Asset.Preview.OneOf_MetaData, rhs: Asset.Preview.OneOf_MetaData) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.image, .image): return {
          guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _mimeType: String?
    fileprivate var _size: UInt64?
    fileprivate var _remote: Asset.RemoteData?
  }

  public struct ImageMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    public var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    public mutating func clearWidth() {self._width = nil}

    public var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    public var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    public mutating func clearHeight() {self._height = nil}

    public var tag: String {
      get {return _tag ?? String()}
      set {_tag = newValue}
    }
    /// Returns true if `tag` has been explicitly set.
    public var hasTag: Bool {return self._tag != nil}
    /// Clears the value of `tag`. Subsequent reads from it will return its default value.
    public mutating func clearTag() {self._tag = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _width: Int32?
    fileprivate var _height: Int32?
    fileprivate var _tag: String?
  }

  public struct VideoMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    public var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    public mutating func clearWidth() {self._width = nil}

    public var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    public var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    public mutating func clearHeight() {self._height = nil}

    public var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    public var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    public mutating func clearDurationInMillis() {self._durationInMillis = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _width: Int32?
    fileprivate var _height: Int32?
    fileprivate var _durationInMillis: UInt64?
  }

  public struct AudioMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    public var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    public mutating func clearDurationInMillis() {self._durationInMillis = nil}

    /// repeated float normalized_loudness = 2 [packed=true]; // deprecated - Switched to bytes instead
    public var normalizedLoudness: Data {
      get {return _normalizedLoudness ?? Data()}
      set {_normalizedLoudness = newValue}
    }
    /// Returns true if `normalizedLoudness` has been explicitly set.
    public var hasNormalizedLoudness: Bool {return self._normalizedLoudness != nil}
    /// Clears the value of `normalizedLoudness`. Subsequent reads from it will return its default value.
    public mutating func clearNormalizedLoudness() {self._normalizedLoudness = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _durationInMillis: UInt64?
    fileprivate var _normalizedLoudness: Data?
  }

  public struct RemoteData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var otrKey: Data {
      get {return _otrKey ?? Data()}
      set {_otrKey = newValue}
    }
    /// Returns true if `otrKey` has been explicitly set.
    public var hasOtrKey: Bool {return self._otrKey != nil}
    /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
    public mutating func clearOtrKey() {self._otrKey = nil}

    /// obsolete but required for backward compatibility
    public var sha256: Data {
      get {return _sha256 ?? Data()}
      set {_sha256 = newValue}
    }
    /// Returns true if `sha256` has been explicitly set.
    public var hasSha256: Bool {return self._sha256 != nil}
    /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
    public mutating func clearSha256() {self._sha256 = nil}

    public var assetID: String {
      get {return _assetID ?? String()}
      set {_assetID = newValue}
    }
    /// Returns true if `assetID` has been explicitly set.
    public var hasAssetID: Bool {return self._assetID != nil}
    /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
    public mutating func clearAssetID() {self._assetID = nil}

    /// optional bytes asset_token = 4; // deprecated - changed type to string
    public var assetToken: String {
      get {return _assetToken ?? String()}
      set {_assetToken = newValue}
    }
    /// Returns true if `assetToken` has been explicitly set.
    public var hasAssetToken: Bool {return self._assetToken != nil}
    /// Clears the value of `assetToken`. Subsequent reads from it will return its default value.
    public mutating func clearAssetToken() {self._assetToken = nil}

    public var assetDomain: String {
      get {return _assetDomain ?? String()}
      set {_assetDomain = newValue}
    }
    /// Returns true if `assetDomain` has been explicitly set.
    public var hasAssetDomain: Bool {return self._assetDomain != nil}
    /// Clears the value of `assetDomain`. Subsequent reads from it will return its default value.
    public mutating func clearAssetDomain() {self._assetDomain = nil}

    public var encryption: EncryptionAlgorithm {
      get {return _encryption ?? .aesCbc}
      set {_encryption = newValue}
    }
    /// Returns true if `encryption` has been explicitly set.
    public var hasEncryption: Bool {return self._encryption != nil}
    /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
    public mutating func clearEncryption() {self._encryption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _otrKey: Data?
    fileprivate var _sha256: Data?
    fileprivate var _assetID: String?
    fileprivate var _assetToken: String?
    fileprivate var _assetDomain: String?
    fileprivate var _encryption: EncryptionAlgorithm?
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Asset.NotUploaded: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Actual message is encrypted with AES and sent as additional data
public struct External {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var otrKey: Data {
    get {return _otrKey ?? Data()}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  public var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  public mutating func clearOtrKey() {self._otrKey = nil}

  /// sha256 of ciphertext, obsolete but required for backward compatibility
  public var sha256: Data {
    get {return _sha256 ?? Data()}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  public var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  public mutating func clearSha256() {self._sha256 = nil}

  public var encryption: EncryptionAlgorithm {
    get {return _encryption ?? .aesCbc}
    set {_encryption = newValue}
  }
  /// Returns true if `encryption` has been explicitly set.
  public var hasEncryption: Bool {return self._encryption != nil}
  /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
  public mutating func clearEncryption() {self._encryption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _otrKey: Data?
  fileprivate var _sha256: Data?
  fileprivate var _encryption: EncryptionAlgorithm?
}

public struct Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// some emoji reaction or the empty string to remove previous reaction(s)
  public var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  public var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// whether this message was sent to legal hold
  public var legalHoldStatus: LegalHoldStatus {
    get {return _legalHoldStatus ?? .unknown}
    set {_legalHoldStatus = newValue}
  }
  /// Returns true if `legalHoldStatus` has been explicitly set.
  public var hasLegalHoldStatus: Bool {return self._legalHoldStatus != nil}
  /// Clears the value of `legalHoldStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLegalHoldStatus() {self._legalHoldStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _emoji: String?
  fileprivate var _messageID: String?
  fileprivate var _legalHoldStatus: LegalHoldStatus?
}

public struct Calling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String {
    get {return _content ?? String()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: String?
}

public struct DataTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trackingIdentifier: TrackingIdentifier {
    get {return _trackingIdentifier ?? TrackingIdentifier()}
    set {_trackingIdentifier = newValue}
  }
  /// Returns true if `trackingIdentifier` has been explicitly set.
  public var hasTrackingIdentifier: Bool {return self._trackingIdentifier != nil}
  /// Clears the value of `trackingIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearTrackingIdentifier() {self._trackingIdentifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trackingIdentifier: TrackingIdentifier?
}

public struct TrackingIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  public var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  public mutating func clearIdentifier() {self._identifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identifier: String?
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ClientAction: @unchecked Sendable {}
extension EncryptionAlgorithm: @unchecked Sendable {}
extension LegalHoldStatus: @unchecked Sendable {}
extension GenericMessage: @unchecked Sendable {}
extension GenericMessage.OneOf_Content: @unchecked Sendable {}
extension QualifiedUserId: @unchecked Sendable {}
extension QualifiedConversationId: @unchecked Sendable {}
extension Composite: @unchecked Sendable {}
extension Composite.Item: @unchecked Sendable {}
extension Composite.Item.OneOf_Content: @unchecked Sendable {}
extension Button: @unchecked Sendable {}
extension ButtonAction: @unchecked Sendable {}
extension ButtonActionConfirmation: @unchecked Sendable {}
extension Availability: @unchecked Sendable {}
extension Availability.TypeEnum: @unchecked Sendable {}
extension Ephemeral: @unchecked Sendable {}
extension Ephemeral.OneOf_Content: @unchecked Sendable {}
extension Text: @unchecked Sendable {}
extension Knock: @unchecked Sendable {}
extension LinkPreview: @unchecked Sendable {}
extension LinkPreview.OneOf_Preview: @unchecked Sendable {}
extension LinkPreview.OneOf_MetaData: @unchecked Sendable {}
extension Tweet: @unchecked Sendable {}
extension Article: @unchecked Sendable {}
extension Mention: @unchecked Sendable {}
extension Mention.OneOf_MentionType: @unchecked Sendable {}
extension LastRead: @unchecked Sendable {}
extension Cleared: @unchecked Sendable {}
extension MessageHide: @unchecked Sendable {}
extension MessageDelete: @unchecked Sendable {}
extension MessageEdit: @unchecked Sendable {}
extension MessageEdit.OneOf_Content: @unchecked Sendable {}
extension Quote: @unchecked Sendable {}
extension Confirmation: @unchecked Sendable {}
extension Confirmation.TypeEnum: @unchecked Sendable {}
extension Location: @unchecked Sendable {}
extension ImageAsset: @unchecked Sendable {}
extension Asset: @unchecked Sendable {}
extension Asset.OneOf_Status: @unchecked Sendable {}
extension Asset.NotUploaded: @unchecked Sendable {}
extension Asset.Original: @unchecked Sendable {}
extension Asset.Original.OneOf_MetaData: @unchecked Sendable {}
extension Asset.Preview: @unchecked Sendable {}
extension Asset.Preview.OneOf_MetaData: @unchecked Sendable {}
extension Asset.ImageMetaData: @unchecked Sendable {}
extension Asset.VideoMetaData: @unchecked Sendable {}
extension Asset.AudioMetaData: @unchecked Sendable {}
extension Asset.RemoteData: @unchecked Sendable {}
extension External: @unchecked Sendable {}
extension Reaction: @unchecked Sendable {}
extension Calling: @unchecked Sendable {}
extension DataTransfer: @unchecked Sendable {}
extension TrackingIdentifier: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ClientAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESET_SESSION")
  ]
}

extension EncryptionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AES_CBC"),
    1: .same(proto: "AES_GCM")
  ]
}

extension LegalHoldStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED")
  ]
}

extension GenericMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GenericMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    6: .same(proto: "lastRead"),
    7: .same(proto: "cleared"),
    8: .same(proto: "external"),
    9: .same(proto: "clientAction"),
    10: .same(proto: "calling"),
    11: .same(proto: "asset"),
    12: .same(proto: "hidden"),
    13: .same(proto: "location"),
    14: .same(proto: "deleted"),
    15: .same(proto: "edited"),
    16: .same(proto: "confirmation"),
    17: .same(proto: "reaction"),
    18: .same(proto: "ephemeral"),
    19: .same(proto: "availability"),
    20: .same(proto: "composite"),
    21: .same(proto: "buttonAction"),
    22: .same(proto: "buttonActionConfirmation"),
    23: .same(proto: "dataTransfer")
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      case 2: try {
        var v: Text?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .text(v)
        }
      }()
      case 3: try {
        var v: ImageAsset?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .image(v)
        }
      }()
      case 4: try {
        var v: Knock?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .knock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .knock(v)
        }
      }()
      case 6: try {
        var v: LastRead?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .lastRead(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .lastRead(v)
        }
      }()
      case 7: try {
        var v: Cleared?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .cleared(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .cleared(v)
        }
      }()
      case 8: try {
        var v: External?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .external(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .external(v)
        }
      }()
      case 9: try {
        var v: ClientAction?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .clientAction(v)
        }
      }()
      case 10: try {
        var v: Calling?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .calling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .calling(v)
        }
      }()
      case 11: try {
        var v: Asset?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .asset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .asset(v)
        }
      }()
      case 12: try {
        var v: MessageHide?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hidden(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hidden(v)
        }
      }()
      case 13: try {
        var v: Location?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .location(v)
        }
      }()
      case 14: try {
        var v: MessageDelete?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .deleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .deleted(v)
        }
      }()
      case 15: try {
        var v: MessageEdit?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .edited(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .edited(v)
        }
      }()
      case 16: try {
        var v: Confirmation?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .confirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .confirmation(v)
        }
      }()
      case 17: try {
        var v: Reaction?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reaction(v)
        }
      }()
      case 18: try {
        var v: Ephemeral?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .ephemeral(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .ephemeral(v)
        }
      }()
      case 19: try {
        var v: Availability?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .availability(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .availability(v)
        }
      }()
      case 20: try {
        var v: Composite?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .composite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .composite(v)
        }
      }()
      case 21: try {
        var v: ButtonAction?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .buttonAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .buttonAction(v)
        }
      }()
      case 22: try {
        var v: ButtonActionConfirmation?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .buttonActionConfirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .buttonActionConfirmation(v)
        }
      }()
      case 23: try {
        var v: DataTransfer?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .dataTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .dataTransfer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.content {
    case .text?: try {
      guard case .text(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .image?: try {
      guard case .image(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .knock?: try {
      guard case .knock(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .lastRead?: try {
      guard case .lastRead(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cleared?: try {
      guard case .cleared(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .external?: try {
      guard case .external(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .clientAction?: try {
      guard case .clientAction(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    }()
    case .calling?: try {
      guard case .calling(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .asset?: try {
      guard case .asset(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .hidden?: try {
      guard case .hidden(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .location?: try {
      guard case .location(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .deleted?: try {
      guard case .deleted(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .edited?: try {
      guard case .edited(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .confirmation?: try {
      guard case .confirmation(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .reaction?: try {
      guard case .reaction(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .ephemeral?: try {
      guard case .ephemeral(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .availability?: try {
      guard case .availability(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .composite?: try {
      guard case .composite(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .buttonAction?: try {
      guard case .buttonAction(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .buttonActionConfirmation?: try {
      guard case .buttonActionConfirmation(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .dataTransfer?: try {
      guard case .dataTransfer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GenericMessage, rhs: GenericMessage) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QualifiedUserId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "QualifiedUserId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "domain")
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._domain == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: QualifiedUserId, rhs: QualifiedUserId) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._domain != rhs._domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QualifiedConversationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "QualifiedConversationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "domain")
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._domain == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: QualifiedConversationId, rhs: QualifiedConversationId) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._domain != rhs._domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Composite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Composite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .standard(proto: "expects_read_confirmation"),
    3: .standard(proto: "legal_hold_status")
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.items) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._legalHoldStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Composite, rhs: Composite) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Composite.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Composite.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "button")
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Text?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .text(v)
        }
      }()
      case 2: try {
        var v: Button?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .button(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .button(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .text?: try {
      guard case .text(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .button?: try {
      guard case .button(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Composite.Item, rhs: Composite.Item) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Button"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "id")
  ]

  public var isInitialized: Bool {
    if self._text == nil {return false}
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Button, rhs: Button) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ButtonAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ButtonAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "button_id"),
    2: .standard(proto: "reference_message_id")
  ]

  public var isInitialized: Bool {
    if self._buttonID == nil {return false}
    if self._referenceMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._buttonID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._referenceMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._buttonID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._referenceMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ButtonAction, rhs: ButtonAction) -> Bool {
    if lhs._buttonID != rhs._buttonID {return false}
    if lhs._referenceMessageID != rhs._referenceMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ButtonActionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ButtonActionConfirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_message_id"),
    2: .standard(proto: "button_id")
  ]

  public var isInitialized: Bool {
    if self._referenceMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._referenceMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._buttonID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._referenceMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buttonID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ButtonActionConfirmation, rhs: ButtonActionConfirmation) -> Bool {
    if lhs._referenceMessageID != rhs._referenceMessageID {return false}
    if lhs._buttonID != rhs._buttonID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Availability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type")
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Availability, rhs: Availability) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "AVAILABLE"),
    2: .same(proto: "AWAY"),
    3: .same(proto: "BUSY")
  ]
}

extension Ephemeral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ephemeral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expire_after_millis"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    5: .same(proto: "asset"),
    6: .same(proto: "location")
  ]

  public var isInitialized: Bool {
    if self._expireAfterMillis == nil {return false}
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._expireAfterMillis) }()
      case 2: try {
        var v: Text?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .text(v)
        }
      }()
      case 3: try {
        var v: ImageAsset?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .image(v)
        }
      }()
      case 4: try {
        var v: Knock?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .knock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .knock(v)
        }
      }()
      case 5: try {
        var v: Asset?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .asset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .asset(v)
        }
      }()
      case 6: try {
        var v: Location?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .location(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expireAfterMillis {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.content {
    case .text?: try {
      guard case .text(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .image?: try {
      guard case .image(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .knock?: try {
      guard case .knock(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .asset?: try {
      guard case .asset(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .location?: try {
      guard case .location(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ephemeral, rhs: Ephemeral) -> Bool {
    if lhs._expireAfterMillis != rhs._expireAfterMillis {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    3: .standard(proto: "link_preview"),
    4: .same(proto: "mentions"),
    5: .same(proto: "quote"),
    6: .standard(proto: "expects_read_confirmation"),
    7: .standard(proto: "legal_hold_status")
  ]

  public var isInitialized: Bool {
    if self._content == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.linkPreview) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mentions) {return false}
    if let v = self._quote, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._content) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.linkPreview) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mentions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._quote) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._legalHoldStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.linkPreview.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkPreview, fieldNumber: 3)
    }
    if !self.mentions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mentions, fieldNumber: 4)
    }
    try { if let v = self._quote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Text, rhs: Text) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.linkPreview != rhs.linkPreview {return false}
    if lhs.mentions != rhs.mentions {return false}
    if lhs._quote != rhs._quote {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Knock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Knock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hot_knock"),
    2: .standard(proto: "expects_read_confirmation"),
    3: .standard(proto: "legal_hold_status")
  ]

  public var isInitialized: Bool {
    if self._hotKnock == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._hotKnock) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._legalHoldStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hotKnock {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Knock, rhs: Knock) -> Bool {
    if lhs._hotKnock != rhs._hotKnock {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinkPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "url_offset"),
    3: .same(proto: "article"),
    5: .standard(proto: "permanent_url"),
    6: .same(proto: "title"),
    7: .same(proto: "summary"),
    8: .same(proto: "image"),
    9: .same(proto: "tweet")
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._urlOffset == nil {return false}
    if let v = self.preview, !v.isInitialized {return false}
    if let v = self._image, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._urlOffset) }()
      case 3: try {
        var v: Article?
        var hadOneofValue = false
        if let current = self.preview {
          hadOneofValue = true
          if case .article(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preview = .article(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._permanentURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._summary) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 9: try {
        var v: Tweet?
        var hadOneofValue = false
        if let current = self.metaData {
          hadOneofValue = true
          if case .tweet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metaData = .tweet(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._urlOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if case .article(let v)? = self.preview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._permanentURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._summary {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if case .tweet(let v)? = self.metaData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinkPreview, rhs: LinkPreview) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._urlOffset != rhs._urlOffset {return false}
    if lhs.preview != rhs.preview {return false}
    if lhs._permanentURL != rhs._permanentURL {return false}
    if lhs._title != rhs._title {return false}
    if lhs._summary != rhs._summary {return false}
    if lhs._image != rhs._image {return false}
    if lhs.metaData != rhs.metaData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tweet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Tweet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
    2: .same(proto: "username")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tweet, rhs: Tweet) -> Bool {
    if lhs._author != rhs._author {return false}
    if lhs._username != rhs._username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Article"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "permanent_url"),
    2: .same(proto: "title"),
    3: .same(proto: "summary"),
    4: .same(proto: "image")
  ]

  public var isInitialized: Bool {
    if self._permanentURL == nil {return false}
    if let v = self._image, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._permanentURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._summary) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._permanentURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._summary {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Article, rhs: Article) -> Bool {
    if lhs._permanentURL != rhs._permanentURL {return false}
    if lhs._title != rhs._title {return false}
    if lhs._summary != rhs._summary {return false}
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Mention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "qualified_user_id")
  ]

  public var isInitialized: Bool {
    if self._start == nil {return false}
    if self._length == nil {return false}
    if let v = self._qualifiedUserID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._length) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.mentionType != nil {try decoder.handleConflictingOneOf()}
          self.mentionType = .userID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._qualifiedUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if case .userID(let v)? = self.mentionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._qualifiedUserID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Mention, rhs: Mention) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs.mentionType != rhs.mentionType {return false}
    if lhs._qualifiedUserID != rhs._qualifiedUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LastRead"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "last_read_timestamp"),
    3: .standard(proto: "qualified_conversation_id")
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._lastReadTimestamp == nil {return false}
    if let v = self._qualifiedConversationID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._conversationID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._lastReadTimestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._qualifiedConversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastReadTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._qualifiedConversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastRead, rhs: LastRead) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._lastReadTimestamp != rhs._lastReadTimestamp {return false}
    if lhs._qualifiedConversationID != rhs._qualifiedConversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cleared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Cleared"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "cleared_timestamp"),
    3: .standard(proto: "qualified_conversation_id")
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._clearedTimestamp == nil {return false}
    if let v = self._qualifiedConversationID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._conversationID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._clearedTimestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._qualifiedConversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._clearedTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._qualifiedConversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cleared, rhs: Cleared) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._clearedTimestamp != rhs._clearedTimestamp {return false}
    if lhs._qualifiedConversationID != rhs._qualifiedConversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageHide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageHide"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "qualified_conversation_id")
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._messageID == nil {return false}
    if let v = self._qualifiedConversationID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._conversationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._qualifiedConversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._qualifiedConversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageHide, rhs: MessageHide) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._qualifiedConversationID != rhs._qualifiedConversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id")
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageDelete, rhs: MessageDelete) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageEdit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replacing_message_id"),
    2: .same(proto: "text"),
    3: .same(proto: "composite")
  ]

  public var isInitialized: Bool {
    if self._replacingMessageID == nil {return false}
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._replacingMessageID) }()
      case 2: try {
        var v: Text?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .text(v)
        }
      }()
      case 3: try {
        var v: Composite?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .composite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .composite(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._replacingMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.content {
    case .text?: try {
      guard case .text(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .composite?: try {
      guard case .composite(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEdit, rhs: MessageEdit) -> Bool {
    if lhs._replacingMessageID != rhs._replacingMessageID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Quote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quoted_message_id"),
    2: .standard(proto: "quoted_message_sha256")
  ]

  public var isInitialized: Bool {
    if self._quotedMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._quotedMessageID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._quotedMessageSha256) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quotedMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quotedMessageSha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Quote, rhs: Quote) -> Bool {
    if lhs._quotedMessageID != rhs._quotedMessageID {return false}
    if lhs._quotedMessageSha256 != rhs._quotedMessageSha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Confirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    1: .standard(proto: "first_message_id"),
    3: .standard(proto: "more_message_ids")
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._firstMessageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._firstMessageID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.moreMessageIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.moreMessageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.moreMessageIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Confirmation, rhs: Confirmation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._firstMessageID != rhs._firstMessageID {return false}
    if lhs.moreMessageIds != rhs.moreMessageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERED"),
    1: .same(proto: "READ")
  ]
}

extension Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "name"),
    4: .same(proto: "zoom"),
    5: .standard(proto: "expects_read_confirmation"),
    6: .standard(proto: "legal_hold_status")
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._zoom) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._expectsReadConfirmation) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._legalHoldStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._zoom {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expectsReadConfirmation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Location, rhs: Location) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._name != rhs._name {return false}
    if lhs._zoom != rhs._zoom {return false}
    if lhs._expectsReadConfirmation != rhs._expectsReadConfirmation {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .standard(proto: "original_width"),
    5: .standard(proto: "original_height"),
    6: .standard(proto: "mime_type"),
    7: .same(proto: "size"),
    8: .standard(proto: "otr_key"),
    9: .standard(proto: "mac_key"),
    10: .same(proto: "mac"),
    11: .same(proto: "sha256")
  ]

  public var isInitialized: Bool {
    if self._tag == nil {return false}
    if self._width == nil {return false}
    if self._height == nil {return false}
    if self._originalWidth == nil {return false}
    if self._originalHeight == nil {return false}
    if self._mimeType == nil {return false}
    if self._size == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tag) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._originalWidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._originalHeight) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._size) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._otrKey) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._macKey) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self._mac) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self._sha256) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originalWidth {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalHeight {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._macKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageAsset, rhs: ImageAsset) -> Bool {
    if lhs._tag != rhs._tag {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._originalWidth != rhs._originalWidth {return false}
    if lhs._originalHeight != rhs._originalHeight {return false}
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._size != rhs._size {return false}
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._macKey != rhs._macKey {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Asset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "original"),
    3: .standard(proto: "not_uploaded"),
    4: .same(proto: "uploaded"),
    5: .same(proto: "preview"),
    6: .standard(proto: "expects_read_confirmation"),
    7: .standard(proto: "legal_hold_status")
  ]

  fileprivate class _StorageClass {
    var _original: Asset.Original?
    var _status: Asset.OneOf_Status?
    var _preview: Asset.Preview?
    var _expectsReadConfirmation: Bool?
    var _legalHoldStatus: LegalHoldStatus?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _original = source._original
      _status = source._status
      _preview = source._preview
      _expectsReadConfirmation = source._expectsReadConfirmation
      _legalHoldStatus = source._legalHoldStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._original, !v.isInitialized {return false}
      if let v = _storage._status, !v.isInitialized {return false}
      if let v = _storage._preview, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._original) }()
        case 3: try {
          var v: Asset.NotUploaded?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._status != nil {try decoder.handleConflictingOneOf()}
            _storage._status = .notUploaded(v)
          }
        }()
        case 4: try {
          var v: Asset.RemoteData?
          var hadOneofValue = false
          if let current = _storage._status {
            hadOneofValue = true
            if case .uploaded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._status = .uploaded(v)
          }
        }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._preview) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._expectsReadConfirmation) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._legalHoldStatus) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._original {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      switch _storage._status {
      case .notUploaded?: try {
        guard case .notUploaded(let v)? = _storage._status else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      }()
      case .uploaded?: try {
        guard case .uploaded(let v)? = _storage._status else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
      try { if let v = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expectsReadConfirmation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._legalHoldStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset, rhs: Asset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._original != rhs_storage._original {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._expectsReadConfirmation != rhs_storage._expectsReadConfirmation {return false}
        if _storage._legalHoldStatus != rhs_storage._legalHoldStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.NotUploaded: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANCELLED"),
    1: .same(proto: "FAILED")
  ]
}

extension Asset.Original: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".Original"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "name"),
    4: .same(proto: "image"),
    5: .same(proto: "video"),
    6: .same(proto: "audio"),
    7: .same(proto: "source"),
    8: .same(proto: "caption")
  ]

  public var isInitialized: Bool {
    if self._mimeType == nil {return false}
    if self._size == nil {return false}
    if let v = self.metaData, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try {
        var v: Asset.ImageMetaData?
        var hadOneofValue = false
        if let current = self.metaData {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metaData = .image(v)
        }
      }()
      case 5: try {
        var v: Asset.VideoMetaData?
        var hadOneofValue = false
        if let current = self.metaData {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metaData = .video(v)
        }
      }()
      case 6: try {
        var v: Asset.AudioMetaData?
        var hadOneofValue = false
        if let current = self.metaData {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metaData = .audio(v)
        }
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    switch self.metaData {
    case .image?: try {
      guard case .image(let v)? = self.metaData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .video?: try {
      guard case .video(let v)? = self.metaData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.metaData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.Original, rhs: Asset.Original) -> Bool {
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._size != rhs._size {return false}
    if lhs._name != rhs._name {return false}
    if lhs.metaData != rhs.metaData {return false}
    if lhs._source != rhs._source {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".Preview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "remote"),
    4: .same(proto: "image")
  ]

  public var isInitialized: Bool {
    if self._mimeType == nil {return false}
    if self._size == nil {return false}
    if let v = self._remote, !v.isInitialized {return false}
    if let v = self.metaData, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._size) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._remote) }()
      case 4: try {
        var v: Asset.ImageMetaData?
        var hadOneofValue = false
        if let current = self.metaData {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metaData = .image(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._remote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .image(let v)? = self.metaData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.Preview, rhs: Asset.Preview) -> Bool {
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._size != rhs._size {return false}
    if lhs._remote != rhs._remote {return false}
    if lhs.metaData != rhs.metaData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.ImageMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".ImageMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "tag")
  ]

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.ImageMetaData, rhs: Asset.ImageMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.VideoMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".VideoMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .standard(proto: "duration_in_millis")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._durationInMillis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.VideoMetaData, rhs: Asset.VideoMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.AudioMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".AudioMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_in_millis"),
    3: .standard(proto: "normalized_loudness")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._durationInMillis) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._normalizedLoudness) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._normalizedLoudness {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.AudioMetaData, rhs: Asset.AudioMetaData) -> Bool {
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs._normalizedLoudness != rhs._normalizedLoudness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.RemoteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Asset.protoMessageName + ".RemoteData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .standard(proto: "asset_id"),
    5: .standard(proto: "asset_token"),
    7: .standard(proto: "asset_domain"),
    6: .same(proto: "encryption")
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    if self._sha256 == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._otrKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._sha256) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._assetID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._assetToken) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._encryption) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._assetDomain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._assetID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assetToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._assetDomain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Asset.RemoteData, rhs: Asset.RemoteData) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._assetToken != rhs._assetToken {return false}
    if lhs._assetDomain != rhs._assetDomain {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "External"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .same(proto: "encryption")
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._otrKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._sha256) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._encryption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External, rhs: External) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Reaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "legal_hold_status")
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._legalHoldStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._legalHoldStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._legalHoldStatus != rhs._legalHoldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Calling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Calling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content")
  ]

  public var isInitialized: Bool {
    if self._content == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Calling, rhs: Calling) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DataTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trackingIdentifier")
  ]

  public var isInitialized: Bool {
    if let v = self._trackingIdentifier, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trackingIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trackingIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataTransfer, rhs: DataTransfer) -> Bool {
    if lhs._trackingIdentifier != rhs._trackingIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrackingIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrackingIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier")
  ]

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrackingIdentifier, rhs: TrackingIdentifier) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
